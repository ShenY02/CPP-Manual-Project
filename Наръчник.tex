\documentclass[oneside]{book}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[fontsize=12pt]{scrextend}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,bulgarian]{babel}
\usepackage{amsmath,amsthm,amsfonts}
\usepackage[framemethod=tikz]{mdframed}
\usepackage{array}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\definecolor{codegreen}{rgb}{0,0.85,0}
\definecolor{codegray}{rgb}{0.65,0.65,0.65}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.2,0.2,0.25}

\mdfdefinestyle{bg}{
    backgroundcolor=backcolour,
    leftmargin=0pt,
    hidealllines=true,
    innerleftmargin=2pt,
    innerrightmargin=2pt,
    innertopmargin=-4pt,
    innerbottommargin=-4pt
}
\mdfsetup{style=bg}

\lstdefinestyle{mystyle}{
    language=C++,
    texcl=true,
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegray},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codegreen},
    basicstyle=\ttfamily\footnotesize\color{white},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=6pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    extendedchars=\true,
    inputencoding=utf8x
}
\lstset{style=mystyle}

\newcommand*{\code}[1]{\texttt{#1}}
\newcommand*{\cpp}{\texttt{C++}\ }
\newcommand*{\bs}{\textbackslash}

\title{Наръчник\\Как се научих да програмирам на \cpp
с помощта на изкуствен интелект}
\author{Шенер Юмер, 2401321044}
\date{Използван LLM: Aria}

\begin{document}
\maketitle
\tableofcontents
\newpage

\chapter*{Предговор}
\addcontentsline{toc}{chapter}{Предговор}
Здравей, скъпи читателю!

Добре дошъл в твоето пътуване през света на програмирането, пътуване,
което започна с любопитство и ще завърши с осъзнаването, че дори изкуственият
интелект може да бъде учител.

Тази книга е както проектна работа, така и плод на моя опит в изучаването на \cpp,
език, който е едновременно мощен и взискателен. С помощта на изкуствения интелект
Aria от Opera GX, аз се научих да разбирам абстрактни концепции, да решавам сложни
проблеми и да създавам код, който работи.

На тези страници ще ти покажа уроците, които научих от Aria, и стъпка по стъпка ще те
науча как и ти да овладееш тънкостите на езика \cpp. Ще ти докажа, че чрез помощта на 
изкуственият интелект можете да извлечеш изключително много информация за изучаването
на програмни езици и по този начин да се вдъхновиш да се впуснеш в света
на програмирането.

Нека това пътуване те вдъхнови да преоткриеш собствения си потенциал
и да осъзнаеш, че нищо не е невъзможно!

\chapter{Въведение}
Добре дошли в света на \cpp! Този език за програмиране е истински гигант, който стои в основата на безброй приложения, игри и технологии, които използваме всеки ден. \cpp е език, който ви дава мощта да създавате сложни и ефективни програми, да контролирате хардуера на компютъра си и да реализирате най-смелите си идеи. 

Но \cpp не е за начинаещи. Той е мощен и гъвкав, но е и сложен и изисква задълбочено разбиране.  

Какво прави \cpp толкова специален?
\begin{itemize}
    \item[--] Обектно-ориентирано програмиране - \cpp е език, който ви позволява да структурирате програмите си около обекти, които съдържат данни и функции. Това е като да създадете симулация на реалния свят в код, където всеки обект е отделен елемент с собствени характеристики и поведение.
    \item[--] Висока производителност - \cpp е известен с ефективността си. Той ви дава пълен контрол над ресурсите на компютъра и ви позволява да създавате приложения, които работят бързо и ефективно. 
    \item[--] Гъвкавост - \cpp е гъвкав език, който ви позволява да разработвате разнообразни приложения, от операционни системи и игри до приложения за мобилни устройства. 
    \item[--] Широко разпространен - \cpp е широко разпространен език, който се използва от милиони програмисти по целия свят. Това означава, че ще имате лесен достъп до ресурси, общности и поддръжка.
\end{itemize}

Защо да се учите на \cpp?
\begin{itemize}
    \item[--] Мощни приложения - \cpp ви дава мощта да създавате комплексни и ефективни приложения, които могат да решават трудни задачи. 
    \item[--] Дълбоко разбиране - \cpp ви учи да разбирате как работи компютърът и как да управлявате ресурсите му. 
    \item[--] Отворена врата към нови възможности - \cpp е отворена врата към широк спектър от професионални възможности. 
\end{itemize}

В тази книга ще ви запознаем с основите на \cpp и ще ви покажем как да създавате свои собствени програми. Пригответе се за вълнуващо пътешествие в света на програмирането! 

\section{Първи стъпки в \cpp}
В тази глава ще се запознаем с основите на \cpp, като започнем с компилация, компилиране и изпълнение на програми.

\subsection{Компилация и изпълнение}
\cpp е компилиран език. Това означава, че кодът, който пишете, трябва да бъде преведен на машинно разбираем език, преди да може да се изпълни.

Компилацията е процес, който превръща изходния код (текстовият файл, който вие пишете) в изпълним файл.
Изпълним файл е файл, който може да се изпълни от компютъра.

За да компилирате и изпълните \cpp програма, ще ви е необходим компилатор.
Компилатор е програма, която превежда изходния код на \cpp в изпълним файл.

\subsection{Как да компилираме и изпълним програма?}
Ето стъпките, които трябва да следвате, за да компилирате и изпълните \cpp програма:

\begin{enumerate}
    \item[--] Създайте нов текстов файл с разширение .cpp.
    \item[--] Напишете \cpp кода си в този файл.
    \item[--] Отворете командния ред (или терминал) и отидете до директорията, където е вашият текстов файл.
    \item[--] Въведете следната команда, за да компилирате програмата:\\
        \code{g++ име\_на\_файла.cpp -o име\_на\_изпълним\_файл}
    \item[--] Въведете следната команда, за да изпълните програмата:\\
        \code{./име\_на\_изпълним\_файл}
\end{enumerate}

Пример:

Ако вашият файл се казва \code{hello.cpp} и искате да създадете изпълним файл \code{hello}, тогава трябва да въведете следните команди:

\begin{mdframed}\begin{lstlisting}[language=bash]
g++ hello.cpp -o hello
./hello
\end{lstlisting}\end{mdframed}

\subsection{Имплементиране на български език в \cpp}
За да използваме български език в кода на \cpp и в конзолата, трябва първо да
зададем локализацията на проекта:
\begin{mdframed}\begin{lstlisting}
#include <locale>

int main() {
    setlocale(LC_ALL, "Bulgarian");
        // Локализация на кирилицата в проекта

    return 0;
}
\end{lstlisting}\end{mdframed}

\code{\#include <locale>} - Тази линия включва библиотеката \code{locale}, която ни дава достъп до функции за локализация на езици.

\code{setlocale(LC\_ALL, "Bulgarian");} - Стандартна функция за локализация на български език.

\subsection{Първата ни програма}
Ето пример за проста \cpp програма, която извежда текст на екрана:
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <locale>

int main() {
    setlocale(LC_ALL, "Bulgarian");

    std::cout << "Hello, world!" << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}

\code{\#include <iostream>} - Тази линия включва библиотеката \code{iostream}, която ни дава достъп до функции за вход и изход.

\code{int main()} - Тази линия дефинира главната функция на програмата. Всички \cpp програми трябва да имат главна функция.

\code{std::cout <}\code{< "Hello, world!"}\code{ <}\code{< std::endl;} - Тази линия извежда текста\\\code{"Hello, world!"} на екрана.

\code{return 0;} - Тази линия завършва изпълнението на програмата.

\section{Ключови елементи на синтаксиса и семантиката на \cpp}
\subsection{Ключови думи}
Ключовите думи в \cpp са резервирани думи, които имат специално значение за компилатора. Те не могат да се използват като имена на променливи, функции или други идентификатори.

\newcolumntype{C}{ >{\centering\arraybackslash} m{6cm} }
\newcolumntype{D}{ >{\centering\arraybackslash} m{5cm} }
\begin{center}\begin{tabular}{|C|D|}
    \hline Ключова дума    &   Описание\\\hline\hline
    \vspace{3pt}\code{int, float, double, char, bool, void, auto, const, constexpr, decltype}\vspace{3pt} & Типове данни\\\hline
    \vspace{3pt}\code{if, else, else if, switch, case, default, break, continue, goto}\vspace{3pt} & Условни оператори\\\hline
    \vspace{3pt}\code{for, while, do while, break, continue}\vspace{3pt} & Цикли\\\hline
    \vspace{3pt}\code{return, sizeof, new, delete, nullptr, this}\vspace{3pt} & Оператори\\\hline
    \vspace{3pt}\code{namespace, using, struct, class, enum, union, template, typename, friend, operator}\vspace{3pt} & Организъм на кода\\\hline
    \vspace{3pt}\code{public, private, protected, static, virtual, override, final, explicit}\vspace{3pt} & Модификатори за достъп\\\hline
    \vspace{3pt}\code{inline, extern, volatile, mutable, register}\vspace{3pt} & Модификатори за компилация\\\hline
    \vspace{3pt}\code{try, catch, throw, noexcept}\vspace{3pt} & Обработка на изключения\\\hline
\end{tabular}\end{center}

Ключовите думи се използват в \cpp код, за да се определят типове данни, структури, класове, функции и други елементи на програмата.

\textbf{Пример:}
\begin{mdframed}\begin{lstlisting}
int main() {
    int a = 10; // int е ключова дума за дефиниране на целочислена променлива
    if (a > 5) { // if е ключова дума за условен оператор
        std::cout << "a is greater than 5" << std::endl;
    }
    return 0; // return е ключова дума за връщане на статус
}    
\end{lstlisting}\end{mdframed}

\subsection{Специални символи}
В \cpp езикът, освен букви, цифри и ключови думи, има и специални символи, които имат специално значение за компилатора. Тези символи се използват за определяне на оператори, разделителни символи, коментари и други елементи на кода.

\subsubsection{Оператори}
Операторите са специални символи, които извършват операции върху операнди.

\begin{itemize}
    \centering
    \item[] Аритметика
    \begin{itemize}
        \item[] \code{+} (събиране): \code{a + b}
        \item[] \code{-} (изваждане): \code{a - b}
        \item[] \code{*} (умножение): \code{a * b}
        \item[] \code{/} (деление): \code{a / b}
        \item[] \code{\%} (остатък от деление): \code{a \% b}
        \item[] \code{++} (увеличаване): \code{a++}
        \item[] \code{-}\code{-} (намаляване): \code{a-}\code{-}
    \end{itemize}
    \item[] Условни
    \begin{itemize}
        \item[] \code{==} (равенство): \code{a == b}
        \item[] \code{!=} (неравенство): \code{a != b}
        \item[] \code{>} (по-голямо): \code{a > b}
        \item[] \code{<} (по-малко): \code{a < b}
        \item[] \code{>=} (по-голямо или равно): \code{a >= b}
        \item[] \code{<=} (по-малко или равно): \code{a <= b}
        \item[] \code{\&\&} (логическо И): \code{a \&\& b}
        \item[] \code{||} (логическо ИЛИ): \code{a || b}
        \item[] \code{!} (логическо НЕ): \code{!a}
        \item[] \code{?:} (тернарен условен оператор): \code{a ? b : c}
    \end{itemize}
    \item[] Битова аритметика
    \begin{itemize}
        \item[] \code{\&} (битово И): \code{a \& b}
        \item[] \code{|} (битово ИЛИ): \code{a | b}
        \item[] \code{\^{}} (битово ИЗКЛ. ИЛИ): \code{a \^{} b}
        \item[] \code{\~{}} (битово НЕ): \code{\~{}a}
        \item[] \code{<}\code{<} (ляво битово изместване): \code{a <}\code{< b}
        \item[] \code{>}\code{>} (дясно битово изместване): \code{a >}\code{> b}
    \end{itemize}
\end{itemize}

\subsubsection{Разделителни символи}
Разделителните символи се използват за разделяне на различни части на \cpp кода.

Пример:
\begin{itemize}
    \item[] \code{;} (точка и запетая): \code{int a = 10;}
    \item[] \code{,} (запетая): \code{int a = 10, b = 20;}
    \item[] \code{:} (двоеточие): \code{switch (a) \{ case 1: ...; \}}
    \item[] \code{::} (обхват на име): \code{std::cout}
    \item[] \code{.} (член на клас): \code{a.b}
    \item[] \code{->} (член на указател): \code{a->b}
    \item[] \code{[]} (индексиране): \code{a[b]}
    \item[] \code{()} (извикване на функция): \code{a()}
    \item[] \code{\{\}} (блокове код): \code{\{ ... \}}
\end{itemize}

\subsubsection{Коментари}
Коментарите са текст, който се игнорира от компилатора. Те се използват за обяснение на кода, добавяне на документация или деактивиране на част от кода.

Пример:
\begin{itemize}
    \item \code{//} (едноредов коментар):
\end{itemize}
\begin{mdframed}\begin{lstlisting}
// This is a single line comment.
\end{lstlisting}\end{mdframed}
\begin{itemize}
    \item \code{/* ... */} (многоредов коментар):
\end{itemize}
\begin{mdframed}\begin{lstlisting}
/*
 * This is a multiline comment.
 * It can extend on multiple lines.
 */
\end{lstlisting}\end{mdframed}

\subsection{Идентификатори}
Идентификаторите в \cpp са имена, които се използват за означаване на променливи, функции, класове, структури, изброявания, области на имена и други елементи на програмата.

\subsubsection{Правила за идентификатори}
Идентификаторите могат да се състоят от букви, цифри, подчертаване (\code{\_}). Първият символ на идентификатора не може да бъде цифра.
Ключовите думи не могат да се използват като идентификатори. Чувствителност към регистъра: \code{myVariable} и \code{MyVariable} са различни идентификатори.

\subsubsection{Примери за идентификатори}
\begin{itemize}
    \item[--] Променлива: \code{age, firstName, totalScore}
    \item[--] Функция: \code{calculateArea, printMessage, sortArray}
    \item[--] Клас: \code{Person, Car, Database}
    \item[--] Структура: \code{Point, Date, Time}
    \item[--] Изброяване: \code{Color, Status, Direction}
    \item[--] Област на имена: \code{std, myNamespace, utils}
\end{itemize}

\subsubsection{Препоръки за идентификатори}
Използвайте описателни имена, които отразяват целта на идентификатора. Използвайте \code{camelCase} или \code{snake\_case} за по-добра четимост.
Избягвайте къси и неясни имена. Не използвайте резервирани думи като идентификатори.

\subsubsection{Пример за код с идентификатори:}
\begin{mdframed}\begin{lstlisting}
#include <iostream>

using namespace std; // Дефиниране на областта на имената "std"

int main() {
    // Дефиниране на променлива с име "age"
    int age = 25;

    // Дефиниране на функция с име "printMessage"
    void printMessage(string message) {
    cout << message << endl;
    }

    // Извикване на функцията "printMessage"
    printMessage("Hello, world!");

    return 0;
}
\end{lstlisting}\end{mdframed}

\subsection{Литерали}
Литералите в \cpp са константни стойности, които се използват за представяне на данни в програмата. Те са директни представяния на данни, които се компилират директно в код.

\subsubsection{Видове литерали}
\cpp поддържа различни видове литерали, в зависимост от типа на данните:

\begin{itemize}
    \item Числови литерали:
    
    \begin{itemize}
        \item Цялочислени литерали:
        \item[] Десетични: \code{10, 25, -15}
        \item[] Осмоични: \code{012, 037} (започват с \code{0})
        \item[] Шестнадесетични: \code{0x1A, 0x2F} (започват с \code{0x})
        \item Дробни литерали: \code{3.14, 1.5e-2} (експоненциална нотация)
    \end{itemize}
    
    \item Символни литерали:
    
    \begin{itemize}
        \item Обикновени: \code{'a', 'B', '\%'}
        \item Escape последователности: \code{'\bs n', '\bs t', '\bs ''}
    \end{itemize}
    \item Текстови литерали:
    
    \begin{itemize}
        \item Обикновени: \code{"Здравей, свят!", "Hello, world!"}
        \item Raw string литерали: \code{R"(C:\bs Users\bs MyUser\bs Documents)"} (за запазване на escape последователности)
    \end{itemize}
    \item Булеви литерали: \code{true, false}
    \item Указателни литерали: \code{nullptr} (за празен указател)
\end{itemize}

\subsubsection{Пример за код с литерали}
\begin{mdframed}\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
    // Цялочислени литерали
    int age = 25;
    int octalNumber = 012;
    int hexNumber = 0x1A;

    // Дробни литерали
    double pi = 3.14;
    double smallNumber = 1.5e-2;

    // Символни литерали
    char character = 'A';
    char newline = '\n';

    // Текстови литерали
    string message = "Hello, world!";
    string path = R"(C:\Users\MyUser\Documents)";

    // Булеви литерали
    bool isTrue = true;
    bool isFalse = false;
\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[firstnumber=26]

    // Указателни литерали
    int* ptr = nullptr;

    return 0;
}
\end{lstlisting}\end{mdframed}

\subsection{Променливи и константи}
\subsubsection{Променливи}
Променливите в \cpp са имена, които се използват за съхраняване на данни в паметта. Тези данни могат да бъдат променяни по време на изпълнението на програмата.

\begin{enumerate}
    \item[1.] Дефиниране на променливи:
\end{enumerate}
\begin{mdframed}\begin{lstlisting}
<datatype> <variable_name>;
\end{lstlisting}\end{mdframed}
\begin{itemize}
    \item[Пример:] 
\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age; // Дефиниране на променлива от тип "int"\ с име "age"
double price; // Дефиниране на променлива от тип "double"\ с име "price"
string name; // Дефиниране на променлива от тип "string"\ с име "name"
\end{lstlisting}\end{mdframed}
\begin{enumerate}
    \item [2.] Инициализиране на променливи\\Инициализирането на променлива е процесът на присвояване на начална стойност при дефинирането.
\end{enumerate}
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age = 25; // Инициализиране на променливата "age"\ със стойност 25
// Инициализиране на променливата "price"\ със стойност 19.99
double price = 19.99;
// Инициализиране на променливата "name"\ със стойност "Ivan"
string name = "Ivan";
\end{lstlisting}\end{mdframed}
\begin{enumerate}
    \item[3.] Използване на променливи\\След дефинирането и инициализирането, променливите могат да се използват в програмата.
\end{enumerate}
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age = 25;
// Извеждане на стойността на променливата "age"
cout << "Your age is: " << age << endl;
\end{lstlisting}\end{mdframed}
\subsubsection{Константи}
Константите в \cpp са имена, които се използват за съхраняване на данни в паметта, но стойностите им не могат да се променят по време на изпълнението на програмата.

\begin{enumerate}
    \item[1.] Дефиниране на константи\\За да се дефинира константа, се използва ключовата дума \code{const}:
\end{enumerate}
\begin{mdframed}\begin{lstlisting}
const <datatype> <NAME_OF_CONSTANT> = <value>;
\end{lstlisting}\end{mdframed}
\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
// Дефиниране на константа от тип "int"\ с име "MAX\_AGE"\ със стойност 120
const int MAX_AGE = 120;
// Дефиниране на константа от тип "double"\ с име "PI"\ със стойност 3.14159
const double PI = 3.14159;
// Дефиниране на константа от тип "string"\ с име "GREETING"
// със стойност "Greetings!"
const string GREETING = "Greetings!";
\end{lstlisting}\end{mdframed}
\begin{enumerate}
    \item[2.] Използване на константи\\Константите могат да се използват в програмата по същия начин като променливите.
\end{enumerate}
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
const int MAX_AGE = 120;
int age = 25;
if (age > MAX_AGE) {
    cout << "Invalid age!" << endl;
}
\end{lstlisting}\end{mdframed}

\subsection{Подпрограми (Функции)}
Функциите в \cpp са блокове от код, които изпълняват конкретна задача. Те могат да приемат аргументи и връщат резултат.

\subsubsection{Функции с тип}
Функциите с тип връщат резултат от конкретен тип.

\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
int sum(int a, int b) {
    return a + b;
}
\end{lstlisting}\end{mdframed}
В този пример функцията \code{sum} приема два целочислени аргумента (\code{a} и \code{b}) и връща цяло число (\code{int}), което е сумата на двата аргумента.

\subsubsection{Void функции}
\code{Void} функциите не връщат резултат. Те се използват за изпълнение на действия, които не връщат стойност.

\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
void printHello() {
    cout << "Hello, world!" << endl;
}
\end{lstlisting}\end{mdframed}
В този пример функцията \code{printHello} не връща резултат. Тя просто извежда текст на конзолата.

\subsubsection{Аргументи на функцията}
Аргументите на функцията са стойности, които се предават на функцията при викането й.
\pagebreak
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
int sum(int a, int b) {
    return a + b;
}

int main() {
    int result = sum(10, 20); // Предаване на аргументите 10 и 20
    cout << result << endl; // Извеждане на резултата (30)
    return 0;
}
\end{lstlisting}\end{mdframed}
В този пример функцията \code{sum} приема два целочислени аргумента (\code{a} и \code{b}). При викането й в \code{main} функцията, се предават стойностите \code{10} и \code{20} за \code{a} и \code{b} съответно.

\subsubsection{Предаване по стойност}
При предаване по стойност, на функцията се предава копия на аргументите.

\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 10;
    int y = 20;
    swap(x, y); // Предаване по стойност
    cout << x << " " << y << endl; // Извеждане на "10 20"
    return 0;
}
\end{lstlisting}\end{mdframed}
В този пример, функцията \code{swap} не модифицира оригиналните стойности на \code{x} и \code{y}, защото работи с копия.

\subsubsection{Предаване по препратка}
При предаване по препратка, на функцията се предава адреса на аргументите.
\pagebreak
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}
    
int main() {
    int x = 10;
    int y = 20;
    swap(x, y); // Предаване по препратка (директен адрес)
    cout << x << " " << y << endl; // Извеждане на "20 10"
    return 0;
}
\end{lstlisting}\end{mdframed}
В този пример, функцията swap модифицира оригиналните стойности на \code{x} и \code{y}, защото работи с адресите им.
\subsubsection{Рекурсия}
Рекурсията е техника, при която функция се вика сама себе си.

\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
\end{lstlisting}\end{mdframed}
В този пример функцията \code{factorial} изчислява факториела на число чрез рекурсивната формула $n! = n \cdot (n-1)!$.

\textbf{Важно}: Рекурсията трябва да има базов случай, който прекратява рекурсивните викания. В противен случай програмата изпада в безкраен цикъл, докато не се стигне до момента, в който паметта, нужна за запазване на променливите и информацията, надвиши разпределената за процеса памет в стека (Stack overflow).

\subsubsection{Lambda функции}
Lambda функциите са анонимни функции, които могат да се дефинират и използват в една линия код.

\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
auto sum = [](int a, int b) {
    return a + b;
};
int result = sum(10, 20); // Извикване на lambda функцията
\end{lstlisting}\end{mdframed}
В този пример lambda функцията \code{sum} приема два целочислени аргумента (\code{a} и \code{b}) и връща цяло число (\code{int}), което е сумата на двата аргумента.

\subsection{Атрибути}
Атрибутите в \cpp са специални ключови думи, които модифицират поведението на променливи, функции, класове и други елементи на кода. Те определят важни характеристики, като обхват, вид, жизнен цикъл, достъп и други.

\subsubsection{Const}
Атрибутът \code{const} определя, че стойността на променливата не може да се променя след инициализирането й. \code{Const} гарантира, че стойността няма да се промени неволно, подобрявайки безопасността на кода.

\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
const int PI = 3.14159;
\end{lstlisting}\end{mdframed}
В този пример \code{PI} е константа с стойност \code{3.14159}.
\subsubsection{Static}
Атрибутът \code{static} определя, че променливата е статична. Статичните променливи съществуват само в рамките на файла, в който са дефинирани. Инициализират се само веднъж при първото викане на файла и живеят цял живот на програмата. Споделят се между всички функции в файла.
\pagebreak
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
static int count = 0;
\end{lstlisting}\end{mdframed}
В този пример \code{count} е статична променлива.

\subsubsection{Extern}
Атрибутът \code{extern} определя, че променливата е дефинирана в друг файл. Атрибутът \code{extern} не инициализира променливата, само указва, че тя съществува някъде друде.

\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
extern int count;
\end{lstlisting}\end{mdframed}
В този пример \code{count} е променлива, която е дефинирана в друг файл.

\subsubsection{Volatile}
Атрибутът \code{volatile} указва, че стойността на променливата може да се променя външно, без да се вижда от компилатора. Атрибутът \code{volatile} предотвратява компилатора да оптимизира кода, който работи с променливата. Използва се за променливи, чиято стойност може да се промени от външни фактори, като прекъсвания, таймери или други процеси.

\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
volatile int counter;
\end{lstlisting}\end{mdframed}
В този пример \code{counter} е променлива, чиято стойност може да се променя от външен код.

\subsubsection{Register}
Атрибутът \code{register} препоръчва на компилатора да съхранява променливата в регистър на процесора. Атрибутът \code{register} е само препоръка. Не гарантира, че компилаторът ще съхрани променливата в регистър. Използва се за често използвани променливи, за да се подобри ефективността.
\pagebreak
\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
register int i;
\end{lstlisting}\end{mdframed}
В този пример \code{i} е променлива, която компилаторът може да съхрани в регистър.

\subsubsection{Auto}
Атрибутът \code{auto} позволява на компилатора да определи типа на променливата автоматично. \code{Auto} улеснява кода, когато типът на променливата е ясен от инициализацията.

\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
auto x = 10;
\end{lstlisting}\end{mdframed}
В този пример \code{x} е променлива с тип \code{int}, определен автоматично от компилатора.

\section{Стандартен конзолен I/O в \cpp}
В тази част ще разгледаме как се работи със системната конзола за стандартно въвеждане и извеждане на информация в \cpp и как да манипулираме получените данни от конзолата, а именно да обработваме информация от \code{string} данните.
\subsection{Работа със системната конзола}
В \cpp за стандартно въвеждане и извеждане на данни се използва пакетът \code{<iostream>}. Той предоставя обекти, които улесняват взаимодействието с потребителя и файловете.

\begin{itemize}
    \item \code{std::cin} - Стандартен входен поток (конзола).
    \item \code{std::cout} - Стандартен изходен поток (конзола).
    \item \code{std::cerr} - Стандартен изходен поток за грешки (конзола).
    \item \code{std::endl} - \code{'\bs n'} (Нов ред).
\end{itemize}

Операторите \code{>}\code{>} и \code{<}\code{<} са специални оператори, които улесняват взаимодействието с \code{cin} и \code{cout}.

\begin{itemize}
    \item \code{>}\code{>} - Операторът за въвеждане.
    \item \code{<}\code{<} - Операторът за извеждане.
\end{itemize}
\pagebreak
\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}{C++}
#include <iostream>

int main() {
    int number;
    std::cout << "Insert a number: "; // Извеждане на текст на конзолата
    std::cin >> number; // Въвеждане на число от конзолата
    // Извеждане на числото на конзолата
    std::cout << "The inserted number is: " << number << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}

\subsubsection{Пакет \code{<iomanip>}}
Пакетът \code{<iomanip>} предоставя методи за манипулиране на входящите и изходящите данни.

\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <iomanip>

int main() {
    double number = 123.456789;
    std::cout << "The number is: " 
        << std::setprecision(4) << number << std::endl;
    std::cout << "The number is: " 
        << std::setw(10) << number << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}
В този пример:

\code{std::setprecision(4)} - ограничава точните цифри на числото до 4.

\code{std::setw(10)} - задава ширина на полето за извеждане на числото на 10 символа.

\begin{itemize}
    \item[Резултат:]
\end{itemize} 
\vspace{-4pt}\begin{mdframed}\begin{lstlisting}[language=bash]
The number is: 123.5
The number is:      123.5
\end{lstlisting}\end{mdframed}

\subsubsection{Допълнителни методи}
Пакетът \code{<iomanip>} предлага много други методи за форматиране на входящите и изходящите данни.

Някои от тях са:
\begin{itemize}
    \item \code{std::fixed} - Извежда числа с фиксирана точка.
    \item \code{std::scientific} - Извежда числа в научен запис.
    \item \code{std::left} - Подравнява текста вляво.
    \item \code{std::right} - Подравнява текста вдясно.
\end{itemize}

\subsection{Работа със \code{string} данни}\label{sec:string}
В \cpp класът \code{std::string} предоставя мощен инструмент за работа с текстови низове. Той осигурява множество функции за манипулиране, сравняване, търсене и модифициране на текстови низове.

\subsubsection{Инициализиране на \code{string}}
Има няколко начина за инициализиране на string обект:

Празен \code{string}:
\begin{mdframed}\begin{lstlisting}
std::string text; // Инициализира празен string
\end{lstlisting}\end{mdframed}

С текстова константа:
\vspace{-4pt}\begin{mdframed}\begin{lstlisting}
// Инициализира string с текстова константа
std::string text = "Hello, world!";
\end{lstlisting}\end{mdframed}

С друг \code{string}:
\vspace{-4pt}\begin{mdframed}\begin{lstlisting}
std::string text1 = "Hello, ";
// Инициализира string с конкатенация на други string-ове
std::string text2 = text1 + "world!";
\end{lstlisting}\end{mdframed}

С масив от символи:
\vspace{-4pt}\begin{mdframed}\begin{lstlisting}
char text[] = "Hello, world!"; // string в стил C
// Инициализира string в стил \cpp с масив от символи
std::string textString(text);
\end{lstlisting}\end{mdframed}

\begin{center}\textbf{Основни функции}\end{center}

\newcolumntype{E}{ >{\centering\arraybackslash} m{8cm} }
\begin{center}\begin{tabular}{|E|C|}
    \hline
    \code{getline(istream\& is, string\& str, char delim)} & \vspace{3pt}Въвежда редове от стандартен вход (\code{cin}) в \code{string} обект. \code{delim} определя разделителя на редовете. По подразбиране разделителят е \code{'\bs n'} (нов ред).\vspace{3pt}\\\hline
    \code{length()} & \vspace{3pt}Връща дължината на текстовия низ.\vspace{3pt}\\\hline
    \code{at(size\_t pos)} & \vspace{3pt}Връща символа на позиция \code{pos} в текстовия низ.\vspace{3pt}\\\hline
    \code{append(const string\& str)}\hfil \code{"}\code{+"} & \vspace{3pt}Добавя текстов низ \code{str} към края на текстовия низ.\vspace{3pt}\\\hline
    \code{compare(const string\& str)}\hfil \code{"}\code{=="} & \vspace{3pt}Сравнява текстовия низ с \code{str}. Връща \code{0}, ако низовете са равни; \code{<0}, ако текстовият низ е по-къс от \code{str}; \code{>0}, ако текстовият низ е по-дълъг от \code{str}.\vspace{3pt}\\\hline
    \code{substr(size\_t pos, size\_t len)} & \vspace{3pt}Връща подниз от текстовия низ, започвайки от позиция \code{pos} и с дължина \code{len}.\vspace{3pt}\\\hline
    \code{find(const string\& str, size\_t pos)} & \vspace{3pt}Търси подниз \code{str} в текстовия низ, започвайки от позиция \code{pos}. Връща позицията на първото намиране на \code{str}, ако е намерен, иначе връща \code{string::npos}.\vspace{3pt}\\\hline
    \code{replace(size\_t pos, size\_t len, const string\& str)} & \vspace{3pt}Заменя подниз от текстовия низ, започвайки от позиция \code{pos} и с дължина \code{len} с \code{str}.\vspace{3pt}\\\hline
    \code{insert(size\_t pos,\hfil const string\& str)} & \vspace{3pt}Вмъква \code{str} в текстовия низ на позиция \code{pos}.\vspace{3pt}\\\hline
    \code{erase(size\_t pos, size\_t len)} & \vspace{3pt}Премахва подниз от текстовия низ, започвайки от позиция \code{pos} и с дължина \code{len}.\vspace{3pt}\\\hline
\end{tabular}\end{center}
\pagebreak

\textbf{Примери:}
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <string>

using namespace std;

int main() {
    string text = "Hello, world!";

    // Въвеждане на текст от конзолата
    cout << "Insert text: ";
    getline(cin, text);

    // Извеждане на дължината на текста
    cout << "The length of the text is: " << text.length() << endl;

    // Извеждане на символа на позиция 5
    cout << "The character at position 5 is: "
        << text.at(5) << endl;

    // Добавяне на текст към края
    text.append(" How are you?");
    cout << "The text is: " << text << endl;

    // Сравняване на два текста
    string otherText = "Hello, world!";
    if (text.compare(otherText) == 0) {
        cout << "The texts are equal." << endl;
    } else {
        cout << "The texts are not equal." << endl;
    }

    // Извеждане на подниз
    cout << "The substring from position 7 to the end is: "
        << text.substr(7) << endl;

    // Търсене на подниз
    size_t pos = text.find("world");
    if (pos != string::npos) {
        cout << "The substring \"world\" was found at position: "
            << pos << endl;
    } else {
        cout << "The substring \"world\" wasn't found." << endl;
    }
\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[firstnumber=last]
    
    // Замяна на подниз
    text.replace(7, 5, "universe");
    cout << "The text is: " << text << endl;

    // Вмъкване на текст
    text.insert(7, "beautiful ");
    cout << "The text is: " << text << endl;

    // Премахване на текст
    text.erase(7, 10);
    cout << "The text is: " << text << endl;

    return 0;
}
\end{lstlisting}\end{mdframed}

\textbf{Резултат:} (Примерен входен текст: Hello, world!)
\begin{mdframed}\begin{lstlisting}[language=bash]
Insert text: >>Hello, world!
The length of the text is: 13
The character at position 5 is: ,
The text is: Hello, world! How are you?
The texts are not equal.
The substring from position 7 to the end is: world! How are you?
The substring "world" was found at position: 7
The text is: Hello, universe! How are you?
The text is: Hello, beautiful universe! How are you?
The text is: Hello, universe! How are you?
\end{lstlisting}\end{mdframed}

\section{Структуриране на \cpp програма}
\subsection{Директиви към предпроцесора}
Предпроцесорът е ключов компонент в \cpp компилационния процес, който обработва кода преди да бъде компилиран. Той изпълнява специални инструкции, наречени директиви, които променят структурата на кода преди да бъде предаден на компилатора.

Най-често използваните директиви към предпроцесора в \cpp са:

\subsubsection{\#include}
\code{\#include} е най-често използваната директива. Тя включва съдържанието на друг файл в текущия файл. Това е ключово за организирането на \cpp код в отделни файлове, например за дефиниране на функции или класове в отделни \code{.h} файлове.

Стандартни файлове: \code{\#include} се използва за включване на стандартни библиотеки, например:
\begin{mdframed}\begin{lstlisting}
// Включва стандартния header файл за входящи и изходящи операции
#include <iostream>
\end{lstlisting}\end{mdframed}

Потребителски файлове: \code{\#include} се използва за включване на файлове, създадени от програмиста, например:
\begin{mdframed}\begin{lstlisting}
#include "my_functions.h" // Включва файл с дефиниции на функции
\end{lstlisting}\end{mdframed}

\subsubsection{\#define}
\code{\#define} се използва за дефиниране на константи и макроси. Константите са променливи, чиято стойност не може да бъде променена след дефинирането им. Макросите са блокове код, които се заменят с дефинираното съдържание по време на предпроцесорната обработка.

Дефиниране на константи:
\begin{mdframed}\begin{lstlisting}
#define PI 3.14159 // Дефинира константа PI
#define MAX\_SIZE 100 // Дефинира константа MAX\_SIZE
\end{lstlisting}\end{mdframed}

Дефиниране на макроси:
\begin{mdframed}\begin{lstlisting}
#define SQUARE(x) (x * x) // Дефинира макрос за изчисляване на квадрат
// Дефинира макрос за извеждане на съобщение
#define PRINT_MESSAGE(msg) std::cout << msg << std::endl;
\end{lstlisting}\end{mdframed}

\subsubsection{\#undef}
\code{\#undef} се използва за премахване на предишно определение на константа или макрос.

\begin{mdframed}\begin{lstlisting}
#undef PI // Премахва определението на PI
\end{lstlisting}\end{mdframed}

\subsubsection{\#ifdef, \#ifndef, \#else, \#endif}
Тези директиви се използват за условно компилиране на код. Тоест, определени части от кода се компилират само ако е изпълнено определено условие.

\begin{itemize}
    \item[--] \code{\#if} - Позволява условно компилиране на код въз основа на резултата от препроцесорно условие.
    Това условие може да бъде дефинирана константа (\code{\#if defined(MY\_CONSTANT)}), макрос (\code{\#if SQUARE(5) == 25}),
    оператори за сравнение (\code{\#if 10 > 5}), логически оператори (\code{\#if defined(DEBUG) \&\& defined(RELEASE)}).
    \item[--] \code{\#ifdef} - Проверява дали константа или макрос е дефиниран.
    \item[--] \code{\#ifndef} - Проверява дали константа или макрос не е дефиниран.
    \item[--] \code{\#else} - Изпълнява се, ако условието в \code{\#if}, \code{\#ifdef} или \code{\#ifndef} не е изпълнено.
    \item[--] \code{\#endif} - Завършва блока, дефиниран от \code{\#if}, \code{\#ifdef}, \code{\#ifndef} или \code{\#else}.
\end{itemize}

\begin{itemize}\item [Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#define SIX 6

#if defined(SIX)
    #pragma message("The constant SIX is defined.")
#endif

#if (SIX > 5)
    #pragma message("6 is greater than 5.")
#endif

#undef SIX

#ifdef SIX
    // Този ред ще се компилира само ако е дефинирана константата SIX
    #pragma message("The constant SIX is defined.")
#else
    // Този ред ще се компилира само ако константата SIX не е дефинирана
    #pragma message("The constant SIX is not defined.")
#endif
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item [Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language=bash]
>| The constant SIX is defined.
>| 6 is greater than 5.
>| The constant SIX is not defined.
\end{lstlisting}\end{mdframed}
\subsubsection{\#pragma}
\code{\#pragma} е директива, която предоставя инструкции на компилатора. Тези инструкции са специфични за компилатора и могат да се различават между различните компилатори.

\code{\#pragma message(STRING)} - Извежда съобщения в конзолата по време на компилирането. Това е полезно при дебъгване на компилаторни проблеми.
\begin{mdframed}\begin{lstlisting}
// Изписва съобщението "Hello, world!"\ редом с другите съобщения от компилатора
#pragma message("Hello, world!");
\end{lstlisting}\end{mdframed}

\code{\#pragma once} - Предотвратява многократно включване на header файл. Това е полезно за предотвратяване на грешки при компилация, когато един и същ header файл се включва многократно.
\begin{mdframed}\begin{lstlisting}
#pragma once // Предотвратява многократно включване на header файл
\end{lstlisting}\end{mdframed}

\subsubsection{\#error}
\code{\#error} е директива, която генерира грешка по време на компилация. Това е полезно за сигнализиране на грешки, които не могат да бъдат открити от компилатора.

\begin{itemize}\item [Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#if !defined(MY_CONSTANT)
    #error "The constant MY_CONSTANT is not defined!"
#endif
\end{lstlisting}\end{mdframed}
В този пример, ако константата \code{MY\_CONSTANT} не е дефинирана, компилаторът ще генерира грешка с текст \code{"The constant MY\_CONSTANT is not defined!"}.

\subsection{Области на имената}
Областите на имената (namespaces) в \cpp са механизъм за организиране на код в логически групи. Те са особено полезни за:

\begin{itemize}
    \item[] Избягване на конфликти на имена: В големи проекти, с множество модули и библиотеки, е възможно да се използват едни и същи имена за различни променливи, функции, класове и т.н. Областите на имената позволяват да се групират тези елементи, като им се дава уникално име за всяка група.
    \item[] Подобрена четливост: Те структурират кода, правейки го по-лесен за четене и разбиране.
    \item[] По-лесно управление на зависимостта: Могат да се използват за управление на зависимостта между различни части от кода.
\end{itemize}

\subsubsection{Дефиниране на области на имената}
В \cpp се дефинират области на имената с ключовата дума \code{namespace}. Синтаксисът е следният:

\begin{mdframed}\begin{lstlisting}
namespace <name_of_namespace> {
    // Дефиниции на променливи, функции, класове, т.н.
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
namespace MyNamespace {
    int x = 10;
    void printX() {
        std::cout << "x = " << x << std::endl;
    }
}
\end{lstlisting}\end{mdframed}

\subsubsection{Използване на области на имената}
За да се достъпи до елемент в област на имената, се използва операторът за обхват (\code{::}).
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int main() {
    MyNamespace::printX(); // Извиква функцията printX() от MyNamespace
    // Достъп до променливата x от MyNamespace
    std::cout << MyNamespace::x << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language=bash]
x = 10
10
\end{lstlisting}\end{mdframed}

Могат да се дефинират области на имената, вложени една в друга.

Ключовата дума \code{using} може да се използва за импортиране на всички елементи от дадена област на имената.
Може да се използва за дефиниране на алиас за елемент от област на имената.

\begin{itemize}\item[Пример] за \code{using}:\end{itemize}
\begin{mdframed}\begin{lstlisting}
using namespace MyNamespace; // Импортиране на всички елементи от MyNamespace

int main() {
    printX(); // Извиква функцията printX() от MyNamespace
    // Достъп до променливата x от MyNamespace
    std::cout << x << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language=bash]
x = 10
10
\end{lstlisting}\end{mdframed}

\chapter{Типове данни}
В \cpp типовете данни определят вида на данните, които можем да съхраняваме в променливи. Те ни казват каква информация може да се съхранява, как се интерпретира и какви операции могат да се извършват с нея.
\section{Типове данни за цели и реални числа}
В \cpp имаме няколко типа данни, които се използват за представяне на цели и реални числа:

Целочислени типове:
\begin{itemize}
    \item[--] \code{int}: Най-често използваният тип за цели числа. Обикновено заема 4 байта в паметта и може да съхранява числа в диапазона от -2,147,483,648 до 2,147,483,647.
    \item[--] \code{short}: Целочислени числа с по-малка големина, обикновено 2 байта. Диапазонът е от -32,768 до 32,767.
    \item[--] \code{long}: Целочислени числа с по-голяма големина, обикновено 4 байта. Диапазонът е от -2,147,483,648 до 2,147,483,647.
    \item[--] \code{long long}: Целочислени числа с още по-голяма големина, обикновено 8 байта. Диапазонът е от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807.
    \item[--] \code{unsigned int}: Неотрицателни цели числа. Диапазонът е (обикновено) от 0 до 4,294,967,295.
    \item[--] \code{unsigned short}: Неотрицателни цели числа с по-малка големина. Диапазонът е от 0 до 65,535.
    \item[--] \code{unsigned long}: Неотрицателни цели числа с по-голяма големина. Диапазонът е от 0 до 4,294,967,295.
    \item[--] \code{unsigned long long}: Неотрицателни цели числа с още по-голяма големина. Диапазонът е от 0 до 18,446,744,073,709,551,615.
\end{itemize}

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age = 25;
short year = 2023;
long population = 8000000;
long long bigNumber = 999999999999999999;
unsigned int counter = 0;
unsigned short port = 80;
unsigned long fileSize = 1024 * 1024 * 1024;
unsigned long long veryBigNumber = 18446744073709551615;
\end{lstlisting}\end{mdframed}

Типове с плаваща запетая:
\begin{itemize}
    \item[--] \code{float}: Числа с плаваща запетая с по-ниска прецизност, обикновено 4 байта.
    \item[--] \code{double}: Числа с плаваща запетая с по-висока прецизност, обикновено 8 байта.
    \item[--] \code{long double}: Числа с плаваща запетая с още по-висока прецизност, обикновено 16 байта.
\end{itemize}

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
float temperature = 25.5;
double pi = 3.141592653589793;
long double veryPreciseNumber = 3.1415926535897932384626433832795;
\end{lstlisting}\end{mdframed}

\section{Типове данни за символ и низ}
В \cpp имаме два основни типа данни, които се използват за представяне на текст:

\subsubsection{Символ (\code{char})}
Използва се за съхраняване на единичен символ, като буква, цифра или специален знак. Заема 1 байт в паметта.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
char letter = 'A';
char digit = '7';
char specialSymbol = '\%';
\end{lstlisting}\end{mdframed}

\subsubsection{Низ (като масив от символи)}
В \cpp низовете могат да се представят и като масиви от символи. Това е по-старият начин за работа с текст в \cpp (произлизащ от низовете в \code{C}).

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
char greeting[] = "Greetings!";
\end{lstlisting}\end{mdframed}

Този код дефинира масив от символи \code{greeting}, който съдържа низа \\\code{"Greetings"}. Важно е да се отбележи, че масивът \code{greeting} трябва да е с достатъчно голям размер, за да събере всички символи от низа, плюс един допълнителен символ \code{'\bs{0}'} (null terminator), който маркира края на низа.

За повече информация за масиви, виж (\ref{sec:array}).

\subsubsection{Низ (\code{string})}
Използва се за съхраняване на поредица от символи, т.е. текст. Представлява обект от класа \code{std::string}, дефиниран в заглавния файл \code{<string>}.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
std::string greeting = "Greetings!";
\end{lstlisting}\end{mdframed}

За повече информация за работа със \code{string} данни, виж (\ref{sec:string}).

\subsubsection{Извличане на числа от \code{string} данни}
За да извлечем число от \code{string}, можем да използваме функциите \code{stoi()}, \code{stol()}, \code{stoll()}, \code{stof()}, \code{stod()}, \code{stold()}, които се намират в заглавния файл \code{<string>}.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <string>

int main() {
    std::string numberString = "12345";
    int numberInt = std::stoi(numberString);
    std::cout << "The number is: " << numberInt << std::endl;

    std::string realNumberString = "3.14159";
    double realNumberDouble = std::stod(realNumberString);
    std::cout << "The real number is: "
        << realNumberDouble << std::endl;

    return 0;
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language=bash]
The number is: 12345
The real number is: 3.14159
\end{lstlisting}\end{mdframed}

\textbf{Важно}: Функциите \code{stoi()}, \code{stol()}, \code{stoll()}, \code{stof()}, \code{stod()}, \code{stold()} хвърлят \code{Exception} (виж \ref{sec:exceptions}) от тип \code{std::invalid\_argument}, ако низът не е валидно число.

\section{Логически данни}
В \cpp имаме логически тип данни (\code{bool}), който може да приема само две стойности:

\begin{itemize}
    \item[] \code{true}: Истина
    \item[] \code{false}: Неистина
\end{itemize}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
bool isSunny = true;
bool isRainy = false;
\end{lstlisting}\end{mdframed}

Логическите данни се използват за представяне на условия, които могат да бъдат истинни или неистинни.
В \cpp \code{true} се представя като \code{1} (или всичко различно от \code{0}), а \code{false} се представя като \code{0}.
Логическите операции, като например \code{\&\&} (И), \code{||} (ИЛИ), \code{!} (НЕ), се използват за комбиниране на логически условия.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
bool isSunny = true;
bool isWarm = true;

bool isPerfectDay = isSunny && isWarm; // true

bool isNotPerfectDay = !isPerfectDay; // false
\end{lstlisting}\end{mdframed}

\subsubsection{Използване на логически данни}
Логическите данни се използват широко в \cpp за:
\begin{itemize}
    \item Условни оператори (\code{if}, \code{else if}, \code{else}): За да се изпълнява код само ако дадено условие е истинно.
    \item Цикли (\code{for}, \code{while}, \code{do while}): За да се изпълнява код, докато дадено условие е истинно.
    \item Функции: За да се връщат логически стойности.
\end{itemize}

За условните оператори и циклите ще научим в следващата глава.

\chapter{Конструкции за поточен контрол}
В \cpp протичането на програмата може да се контролира чрез различни конструкции, които определят дали дадени части от кода ще бъдат изпълнени или не.
Тези конструкции са съответно за разклонение в потока, за цикли, за прекъсване и за управление на изключения.

\section{Конструкции за разклонение}
Конструкциите за разклонение ни позволяват да изпълняваме различни части от код в зависимост от резултата от дадено условие. В \cpp имаме 3 основни конструкции за разклонение и 2 алтернативни варианта (частни случаи):
\subsubsection{I. \code{if} оператор}

Използва се за изпълнение на код, само ако дадено условие е истинно.
\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
if (condition) {
    // Код, който се изпълнява, ако условието е истинно
}
// или
if (condition) /* Код за изпълнение */;
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age = 25;

if (age >= 18) {
    std::cout << "You're old enough." << std::endl;
}
\end{lstlisting}\end{mdframed}
\subsubsection{II. \code{if-else} оператор}
Използва се за изпълнение на един от два кода, в зависимост от резултата от дадено условие.

\begin{itemize}\item[Синтаксис:]\end{itemize}\vspace{-6pt}
\begin{mdframed}\begin{lstlisting}
if (condition) {
    // Код, който се изпълнява, ако условието е истинно
} else {
    // Код, който се изпълнява, ако условието е неистинно
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Пример:]\end{itemize}\vspace{-6pt}
\begin{mdframed}\begin{lstlisting}
int age = 15;

if (age >= 18) {
    std::cout << "You're old enough." << std::endl;
} else {
    std::cout << "You're not old enough." << std::endl;
}
\end{lstlisting}\end{mdframed}

\subsubsection{Тернарен оператор (\code{?:})}
Представлява по-кратка форма за писане на \code{if-else} конструкция, когато трябва да запишем стойност на променлива, в зависимост от някакво условие.

\begin{itemize}\item[Синтаксис:]\end{itemize}\vspace{-6pt}
\begin{mdframed}\begin{lstlisting}
<type> <var_name> = <conditon> ? <val_if_true> : <val_if_false>;
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age = 25;

// `if-else` в случая е по-обемен
if (age >= 18) {
    std::cout << "Adult" << std::endl;
} else {
    std::cout << "Minor" << std::endl;
}

// С тернарен оператор кода става сравнително по-компактен
std::cout << ((age >= 18) ? "Adult" : "Minor") << std::endl;
\end{lstlisting}\end{mdframed}

\subsubsection{III. \code{else-if} оператор}
Използва се за изпълнение на един от няколко кода, в зависимост от резултата от няколко условия.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
if (condition_1) {
    // Код, който се изпълнява, ако condition\_1 е истинно
} else if (condition_2) {
    // Код, който се изпълнява, ако condition\_2 е истинно
} else {
    // Код, който се изпълнява, ако никое от условията не е истинно
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Пример:]\end{itemize}\vspace{-6pt}
\begin{mdframed}\begin{lstlisting}
int grade = 85;

if (grade >= 90) {
    std::cout << "A" << std::endl;
} else if (grade >= 80) {
    std::cout << "B" << std::endl;
} else if (grade >= 70) {
    std::cout << "C" << std::endl;
} else {
    std::cout << "F" << std::endl;
}
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Резултат:]\end{itemize}\vspace{-18pt}
\begin{mdframed}\begin{lstlisting}[language=bash]
B
\end{lstlisting}\end{mdframed}

\subsubsection{\code{switch} оператор}
Използва се за проверка на стойността на дадена променлива и изпълнение на код, съответстващ на тази стойност.

\begin{itemize}\item[Синтаксис:]\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}
switch (variable) {
    case value_1:
        // Код, който се изпълнява, ако изразът е равен на value\_1
        break;
    case value_2:
        // Код, който се изпълнява, ако изразът е равен на value\_2
        break;
    default:
        // Код, който се изпълнява, ако изразът
        // не е равен на никоя от стойностите
}
\end{lstlisting}\end{mdframed}\vspace{-16pt}

\begin{itemize}\item[Пример:]\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}
int day = 3;

switch (day) {
    case 1:
        std::cout << "Monday" << std::endl;
        break;
    case 2:
        std::cout << "Tuesday" << std::endl;
        break;
    case 3:
        std::cout << "Wednesday" << std::endl;
        break;
    default:
        std::cout << "Invalid day" << std::endl;
}
\end{lstlisting}\end{mdframed}\vspace{-16pt}

\begin{itemize}\item[Резултат:]\end{itemize}\vspace{-18pt}
\begin{mdframed}\begin{lstlisting}[language=bash]
Wednesday
\end{lstlisting}\end{mdframed}

\section{Конструкции за цикъл}
Конструкциите за цикли ни позволяват да изпълняваме даден код многократно, докато дадено условие е истинно. В \cpp имаме 3 основни конструкции за цикли и 1 алтернативен вариант (частен случай):

\subsubsection{I. \code{while} цикъл}
Използва се за изпълнение на код докато дадено условие е истинно.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
while (condition) {
    // Код, който се изпълнява многократно
}
\end{lstlisting}\end{mdframed}

\textbf{Условие}: Проверява се преди всяко повторение на цикъла. Ако условието е истинно, цикълът се изпълнява.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int i = 0;

while (i < 5) {
    std::cout << i << std::endl;
    i++;
}
\end{lstlisting}\end{mdframed}

\code{i++}: Увеличава стойността на \code{i} с \code{1} след всяко повторение на цикъла.

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language=bash]
0
1
2
3
4
\end{lstlisting}\end{mdframed}

\textbf{Важно}: Циклите винаги трябва да имат стъпка, в която да се подновява условието, за да се гарантира, че няма да изпадне в безкраен цикъл или изобщо да не се осъществи.

\subsubsection{II. \code{do-while} цикъл}
Използва се за изпълнение на код поне веднъж и след това докато дадено условие е истинно.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
do {
    // Код, който се изпълнява многократно
} while (condition);
\end{lstlisting}\end{mdframed}

\textbf{Условие}: Проверява се след всяко повторение на цикъла. Ако условието е истинно, цикълът се изпълнява отново.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int i = 0;

do {
    std::cout << i << std::endl;
    i++;
} while (i < 5);
\end{lstlisting}\end{mdframed}

\subsubsection{III. \code{for} цикъл}
Използва се за изпълнение на код за определен брой пъти.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
for (initialization; condition; updation) {
    // Код, който се изпълнява многократно
}
\end{lstlisting}\end{mdframed}

\textbf{Инициализация}: Изпълнява се веднъж в началото на цикъла. Обикновено се използва за дефиниране на променлива, която ще се използва за броене на повторенията.

\textbf{Условие}: Проверява се преди всяко повторение на цикъла. Ако условието е истинно, цикълът се изпълнява.

\textbf{Стъпка}: Изпълнява се след всяко повторение на цикъла. Обикновено се използва за промяна на стойността на променливата, използвана за броене.
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
for (int i = 0; i < 5; i++) {
    std::cout << i << std::endl;
}
\end{lstlisting}\end{mdframed}

\subsubsection{\code{for-each} цикъл}
Тази конструкция е частен случай на \code{for} цикъла. Използва се за итериране през елементите на контейнер (например масив, вектор, списък).

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
for (<type> <element> : <container>) {
    // Код, който се изпълнява за всеки елемент
}
\end{lstlisting}\end{mdframed}

\textbf{Тип елемент}: Определя типа на елементите в контейнера.

\textbf{Контейнер}: Определя контейнера от елементи, през който ще се итерира.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int numbers[] = {0, 1, 2, 3, 4}; // Масив от числа

for (int number : numbers) {
    std::cout << number << std::endl;
}
\end{lstlisting}\end{mdframed}

Всяко повторение на цикъла, променливата \code{number} ще приема стойността на следващия елемент в масива \code{numbers}.

\section{Конструкции за прекъсване}
\section{Изключения (Exceptions) и работа с тях}\label{sec:exceptions}

\chapter{Съставни типове данни}
\section{Масиви}\label{sec:array}
\section{Структури}
\section{Класове}
\section{Обединения}
\section{Изброяване}
\section{Колекции}

\chapter{Манипулиране на паметта}
\section{Указатели}
\section{Референции}
\section{Адресна аритметика}
\section{Динамично и статично разпределяне на паметта}

\chapter{Алгоритми}

\chapter*{Реализация на софтуерно приложение "\dots"}
\addcontentsline{toc}{chapter}{Реализация на софтуерно приложение}

\end{document}