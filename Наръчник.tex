\documentclass[oneside]{book}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[fontsize=12pt]{scrextend}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,bulgarian]{babel}
\usepackage{amsmath,amsthm,amsfonts}
\usepackage[framemethod=tikz]{mdframed}
\usepackage{array}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\definecolor{codegreen}{rgb}{0,0.85,0}
\definecolor{codegray}{rgb}{0.65,0.65,0.65}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.2,0.2,0.25}

\mdfdefinestyle{bg}{
    backgroundcolor=backcolour,
    leftmargin=0pt,
    hidealllines=true,
    innerleftmargin=2pt,
    innerrightmargin=2pt,
    innertopmargin=-4pt,
    innerbottommargin=-4pt
}
\mdfsetup{style=bg}

\lstdefinestyle{mystyle}{
    language=C++,
    texcl=true,
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegray},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codegreen},
    basicstyle=\ttfamily\footnotesize\color{white},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=6pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    extendedchars=\true,
    inputencoding=utf8x
}
\lstset{style=mystyle}

\newcommand*{\code}[1]{\texttt{#1}}
\newcommand*{\cpp}{\texttt{C++}\ }
\newcommand*{\bs}{\textbackslash}

\title{Наръчник\\Как се научих да програмирам на \cpp
с помощта на изкуствен интелект}
\author{Шенер Юмер, 2401321044}
\date{Използван LLM: Aria}

\begin{document}
\maketitle
\tableofcontents
\newpage

\chapter*{Предговор}
\addcontentsline{toc}{chapter}{Предговор}
Здравей, скъпи читателю!

Добре дошъл в твоето пътуване през света на програмирането, пътуване,
което започна с любопитство и ще завърши с осъзнаването, че дори изкуственият
интелект може да бъде учител.

Тази книга е както проектна работа, така и плод на моя опит в изучаването на \cpp,
език, който е едновременно мощен и взискателен. С помощта на изкуствения интелект
Aria от Opera GX, аз се научих да разбирам абстрактни концепции, да решавам сложни
проблеми и да създавам код, който работи.

На тези страници ще ти покажа уроците, които научих от Aria, и стъпка по стъпка ще те
науча как и ти да овладееш тънкостите на езика \cpp. Ще ти докажа, че чрез помощта на 
изкуственият интелект можете да извлечеш изключително много информация за изучаването
на програмни езици и по този начин да се вдъхновиш да се впуснеш в света
на програмирането.

Нека това пътуване те вдъхнови да преоткриеш собствения си потенциал
и да осъзнаеш, че нищо не е невъзможно!

\chapter{Въведение}
Добре дошли в света на \cpp! Този език за програмиране е истински гигант, който стои в основата на безброй приложения, игри и технологии, които използваме всеки ден. \cpp е език, който ви дава мощта да създавате сложни и ефективни програми, да контролирате хардуера на компютъра си и да реализирате най-смелите си идеи. 

Но \cpp не е за начинаещи. Той е мощен и гъвкав, но е и сложен и изисква задълбочено разбиране.  

Какво прави \cpp толкова специален?
\begin{itemize}
    \item[--] Обектно-ориентирано програмиране - \cpp е език, който ви позволява да структурирате програмите си около обекти, които съдържат данни и функции. Това е като да създадете симулация на реалния свят в код, където всеки обект е отделен елемент с собствени характеристики и поведение.
    \item[--] Висока производителност - \cpp е известен с ефективността си. Той ви дава пълен контрол над ресурсите на компютъра и ви позволява да създавате приложения, които работят бързо и ефективно. 
    \item[--] Гъвкавост - \cpp е гъвкав език, който ви позволява да разработвате разнообразни приложения, от операционни системи и игри до приложения за мобилни устройства. 
    \item[--] Широко разпространен - \cpp е широко разпространен език, който се използва от милиони програмисти по целия свят. Това означава, че ще имате лесен достъп до ресурси, общности и поддръжка.
\end{itemize}

Защо да се учите на \cpp?
\begin{itemize}
    \item[--] Мощни приложения - \cpp ви дава мощта да създавате комплексни и ефективни приложения, които могат да решават трудни задачи. 
    \item[--] Дълбоко разбиране - \cpp ви учи да разбирате как работи компютърът и как да управлявате ресурсите му. 
    \item[--] Отворена врата към нови възможности - \cpp е отворена врата към широк спектър от професионални възможности. 
\end{itemize}

В тази книга ще ви запознаем с основите на \cpp и ще ви покажем как да създавате свои собствени програми. Пригответе се за вълнуващо пътешествие в света на програмирането! 

\section{Първи стъпки в \cpp}
В тази глава ще се запознаем с основите на \cpp, като започнем с компилация, компилиране и изпълнение на програми.

\subsection{Компилация и изпълнение}
\cpp е компилиран език. Това означава, че кодът, който пишете, трябва да бъде преведен на машинно разбираем език, преди да може да се изпълни.

Компилацията е процес, който превръща изходния код (текстовият файл, който вие пишете) в изпълним файл.
Изпълним файл е файл, който може да се изпълни от компютъра.

За да компилирате и изпълните \cpp програма, ще ви е необходим компилатор.
Компилатор е програма, която превежда изходния код на \cpp в изпълним файл.

\subsection{Как да компилираме и изпълним програма?}
Ето стъпките, които трябва да следвате, за да компилирате и изпълните \cpp програма:

\begin{enumerate}
    \item[--] Създайте нов текстов файл с разширение .cpp.
    \item[--] Напишете \cpp кода си в този файл.
    \item[--] Отворете командния ред (или терминал) и отидете до директорията, където е вашият текстов файл.
    \item[--] Въведете следната команда, за да компилирате програмата:\\
        \code{g++ име\_на\_файла.cpp -o име\_на\_изпълним\_файл}
    \item[--] Въведете следната команда, за да изпълните програмата:\\
        \code{./име\_на\_изпълним\_файл}
\end{enumerate}

Пример:

Ако вашият файл се казва \code{hello.cpp} и искате да създадете изпълним файл \code{hello}, тогава трябва да въведете следните команди:

\begin{mdframed}\begin{lstlisting}[language=bash]
g++ hello.cpp -o hello
./hello
\end{lstlisting}\end{mdframed}

\subsection{Имплементиране на български език в \cpp}
За да използваме български език в кода на \cpp и в конзолата, трябва първо да
зададем локализацията на проекта:
\begin{mdframed}\begin{lstlisting}
#include <locale>

int main() {
    setlocale(LC_ALL, "Bulgarian");
        // Локализация на кирилицата в проекта

    return 0;
}
\end{lstlisting}\end{mdframed}

\code{\#include <locale>} - Тази линия включва библиотеката \code{locale}, която ни дава достъп до функции за локализация на езици.

\code{setlocale(LC\_ALL, "Bulgarian");} - Стандартна функция за локализация на български език.

\subsection{Първата ни програма}
Ето пример за проста \cpp програма, която извежда текст на екрана:
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <locale>

int main() {
    setlocale(LC_ALL, "Bulgarian");

    std::cout << "Hello, world!" << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}

\code{\#include <iostream>} - Тази линия включва библиотеката \code{iostream}, която ни дава достъп до функции за вход и изход.

\code{int main()} - Тази линия дефинира главната функция на програмата. Всички \cpp програми трябва да имат главна функция.

\code{std::cout <}\code{< "Hello, world!"}\code{ <}\code{< std::endl;} - Тази линия извежда текста\\\code{"Hello, world!"} на екрана.

\code{return 0;} - Тази линия завършва изпълнението на програмата.

\section{Ключови елементи на синтаксиса и семантиката на \cpp}
\subsection{Ключови думи}
Ключовите думи в \cpp са резервирани думи, които имат специално значение за компилатора. Те не могат да се използват като имена на променливи, функции или други идентификатори.

\newcolumntype{C}{ >{\centering\arraybackslash} m{6cm} }
\newcolumntype{D}{ >{\centering\arraybackslash} m{5cm} }
\begin{center}\begin{tabular}{|C|D|}
    \hline Ключова дума    &   Описание\\\hline\hline
    \vspace{3pt}\code{int, float, double, char, bool, void, auto, const, constexpr, decltype}\vspace{3pt} & Типове данни\\\hline
    \vspace{3pt}\code{if, else, else if, switch, case, default, break, continue, goto}\vspace{3pt} & Условни оператори\\\hline
    \vspace{3pt}\code{for, while, do while, break, continue}\vspace{3pt} & Цикли\\\hline
    \vspace{3pt}\code{return, sizeof, new, delete, nullptr, this}\vspace{3pt} & Оператори\\\hline
    \vspace{3pt}\code{namespace, using, struct, class, enum, union, template, typename, friend, operator}\vspace{3pt} & Организъм на кода\\\hline
    \vspace{3pt}\code{public, private, protected, static, virtual, override, final, explicit}\vspace{3pt} & Модификатори за достъп\\\hline
    \vspace{3pt}\code{inline, extern, volatile, mutable, register}\vspace{3pt} & Модификатори за компилация\\\hline
    \vspace{3pt}\code{try, catch, throw, noexcept}\vspace{3pt} & Обработка на изключения\\\hline
\end{tabular}\end{center}

Ключовите думи се използват в \cpp код, за да се определят типове данни, структури, класове, функции и други елементи на програмата.

\textbf{Пример:}
\begin{mdframed}\begin{lstlisting}
int main() {
    int a = 10; // int е ключова дума за дефиниране на целочислена променлива
    if (a > 5) { // if е ключова дума за условен оператор
        std::cout << "a is greater than 5" << std::endl;
    }
    return 0; // return е ключова дума за връщане на статус
}    
\end{lstlisting}\end{mdframed}

\subsection{Специални символи}
В \cpp езикът, освен букви, цифри и ключови думи, има и специални символи, които имат специално значение за компилатора. Тези символи се използват за определяне на оператори, разделителни символи, коментари и други елементи на кода.

\subsubsection{Оператори}
Операторите са специални символи, които извършват операции върху операнди.

\begin{itemize}
    \centering
    \item[] Аритметика
    \begin{itemize}
        \item[] \code{+} (събиране): \code{a + b}
        \item[] \code{-} (изваждане): \code{a - b}
        \item[] \code{*} (умножение): \code{a * b}
        \item[] \code{/} (деление): \code{a / b}
        \item[] \code{\%} (остатък от деление): \code{a \% b}
        \item[] \code{++} (увеличаване): \code{a++}
        \item[] \code{-}\code{-} (намаляване): \code{a-}\code{-}
    \end{itemize}
    \item[] Условни
    \begin{itemize}
        \item[] \code{==} (равенство): \code{a == b}
        \item[] \code{!=} (неравенство): \code{a != b}
        \item[] \code{>} (по-голямо): \code{a > b}
        \item[] \code{<} (по-малко): \code{a < b}
        \item[] \code{>=} (по-голямо или равно): \code{a >= b}
        \item[] \code{<=} (по-малко или равно): \code{a <= b}
        \item[] \code{\&\&} (логическо И): \code{a \&\& b}
        \item[] \code{||} (логическо ИЛИ): \code{a || b}
        \item[] \code{!} (логическо НЕ): \code{!a}
        \item[] \code{?:} (тернарен условен оператор): \code{a ? b : c}
    \end{itemize}
    \item[] Битова аритметика
    \begin{itemize}
        \item[] \code{\&} (битово И): \code{a \& b}
        \item[] \code{|} (битово ИЛИ): \code{a | b}
        \item[] \code{\^{}} (битово ИЗКЛ. ИЛИ): \code{a \^{} b}
        \item[] \code{\~{}} (битово НЕ): \code{\~{}a}
        \item[] \code{<}\code{<} (ляво битово изместване): \code{a <}\code{< b}
        \item[] \code{>}\code{>} (дясно битово изместване): \code{a >}\code{> b}
    \end{itemize}
\end{itemize}

\subsubsection{Разделителни символи}
Разделителните символи се използват за разделяне на различни части на \cpp кода.

Пример:
\begin{itemize}
    \item[] \code{;} (точка и запетая): \code{int a = 10;}
    \item[] \code{,} (запетая): \code{int a = 10, b = 20;}
    \item[] \code{:} (двоеточие): \code{switch (a) \{ case 1: ...; \}}
    \item[] \code{::} (обхват на име): \code{std::cout}
    \item[] \code{.} (член на клас): \code{a.b}
    \item[] \code{->} (член на указател): \code{a->b}
    \item[] \code{[]} (индексиране): \code{a[b]}
    \item[] \code{()} (извикване на функция): \code{a()}
    \item[] \code{\{\}} (блокове код): \code{\{ ... \}}
\end{itemize}

\subsubsection{Коментари}
Коментарите са текст, който се игнорира от компилатора. Те се използват за обяснение на кода, добавяне на документация или деактивиране на част от кода.

Пример:
\begin{itemize}
    \item \code{//} (едноредов коментар):
\end{itemize}
\begin{mdframed}\begin{lstlisting}
// This is a single line comment.
\end{lstlisting}\end{mdframed}
\begin{itemize}
    \item \code{/* ... */} (многоредов коментар):
\end{itemize}
\begin{mdframed}\begin{lstlisting}
/*
 * This is a multiline comment.
 * It can extend on multiple lines.
 */
\end{lstlisting}\end{mdframed}

\subsection{Идентификатори}
Идентификаторите в \cpp са имена, които се използват за означаване на променливи, функции, класове, структури, изброявания, области на имена и други елементи на програмата.

\subsubsection{Правила за идентификатори}
Идентификаторите могат да се състоят от букви, цифри, подчертаване (\code{\_}). Първият символ на идентификатора не може да бъде цифра.
Ключовите думи не могат да се използват като идентификатори. Чувствителност към регистъра: \code{myVariable} и \code{MyVariable} са различни идентификатори.

\subsubsection{Примери за идентификатори}
\begin{itemize}
    \item[--] Променлива: \code{age, firstName, totalScore}
    \item[--] Функция: \code{calculateArea, printMessage, sortArray}
    \item[--] Клас: \code{Person, Car, Database}
    \item[--] Структура: \code{Point, Date, Time}
    \item[--] Изброяване: \code{Color, Status, Direction}
    \item[--] Област на имена: \code{std, myNamespace, utils}
\end{itemize}

\subsubsection{Препоръки за идентификатори}
Използвайте описателни имена, които отразяват целта на идентификатора. Използвайте \code{camelCase} или \code{snake\_case} за по-добра четимост.
Избягвайте къси и неясни имена. Не използвайте резервирани думи като идентификатори.

\subsubsection{Пример за код с идентификатори:}
\begin{mdframed}\begin{lstlisting}
#include <iostream>

using namespace std; // Дефиниране на областта на имената "std"

int main() {
    // Дефиниране на променлива с име "age"
    int age = 25;

    // Дефиниране на функция с име "printMessage"
    void printMessage(string message) {
    cout << message << endl;
    }

    // Извикване на функцията "printMessage"
    printMessage("Hello, world!");

    return 0;
}
\end{lstlisting}\end{mdframed}

\subsection{Литерали}
Литералите в \cpp са константни стойности, които се използват за представяне на данни в програмата. Те са директни представяния на данни, които се компилират директно в код.

\subsubsection{Видове литерали}
\cpp поддържа различни видове литерали, в зависимост от типа на данните:

\begin{itemize}
    \item Числови литерали:
    
    \begin{itemize}
        \item Цялочислени литерали:
        \item[] Десетични: \code{10, 25, -15}
        \item[] Осмоични: \code{012, 037} (започват с \code{0})
        \item[] Шестнадесетични: \code{0x1A, 0x2F} (започват с \code{0x})
        \item Дробни литерали: \code{3.14, 1.5e-2} (експоненциална нотация)
    \end{itemize}
    
    \item Символни литерали:
    
    \begin{itemize}
        \item Обикновени: \code{'a', 'B', '\%'}
        \item Escape последователности: \code{'\bs n', '\bs t', '\bs ''}
    \end{itemize}
    \item Текстови литерали:
    
    \begin{itemize}
        \item Обикновени: \code{"Здравей, свят!", "Hello, world!"}
        \item Raw string литерали: \code{R"(C:\bs Users\bs MyUser\bs Documents)"} (за запазване на escape последователности)
    \end{itemize}
    \item Булеви литерали: \code{true, false}
    \item Указателни литерали: \code{nullptr} (за празен указател)
\end{itemize}

\subsubsection{Пример за код с литерали}
\begin{mdframed}\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
    // Цялочислени литерали
    int age = 25;
    int octalNumber = 012;
    int hexNumber = 0x1A;

    // Дробни литерали
    double pi = 3.14;
    double smallNumber = 1.5e-2;

    // Символни литерали
    char character = 'A';
    char newline = '\n';

    // Текстови литерали
    string message = "Hello, world!";
    string path = R"(C:\Users\MyUser\Documents)";

    // Булеви литерали
    bool isTrue = true;
    bool isFalse = false;
\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[firstnumber=26]

    // Указателни литерали
    int* ptr = nullptr;

    return 0;
}
\end{lstlisting}\end{mdframed}

\subsection{Променливи и константи}
\subsubsection{Променливи}
Променливите в \cpp са имена, които се използват за съхраняване на данни в паметта. Тези данни могат да бъдат променяни по време на изпълнението на програмата.

\begin{enumerate}
    \item[1.] Дефиниране на променливи:
\end{enumerate}
\begin{mdframed}\begin{lstlisting}
<datatype> <variable_name>;
\end{lstlisting}\end{mdframed}
\begin{itemize}
    \item[Пример:] 
\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age; // Дефиниране на променлива от тип "int"\ с име "age"
double price; // Дефиниране на променлива от тип "double"\ с име "price"
string name; // Дефиниране на променлива от тип "string"\ с име "name"
\end{lstlisting}\end{mdframed}
\begin{enumerate}
    \item [2.] Инициализиране на променливи\\Инициализирането на променлива е процесът на присвояване на начална стойност при дефинирането.
\end{enumerate}
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age = 25; // Инициализиране на променливата "age"\ със стойност 25
// Инициализиране на променливата "price"\ със стойност 19.99
double price = 19.99;
// Инициализиране на променливата "name"\ със стойност "Ivan"
string name = "Ivan";
\end{lstlisting}\end{mdframed}
\begin{enumerate}
    \item[3.] Използване на променливи\\След дефинирането и инициализирането, променливите могат да се използват в програмата.
\end{enumerate}
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age = 25;
// Извеждане на стойността на променливата "age"
cout << "Your age is: " << age << endl;
\end{lstlisting}\end{mdframed}
\subsubsection{Константи}
Константите в \cpp са имена, които се използват за съхраняване на данни в паметта, но стойностите им не могат да се променят по време на изпълнението на програмата.

\begin{enumerate}
    \item[1.] Дефиниране на константи\\За да се дефинира константа, се използва ключовата дума \code{const}:
\end{enumerate}
\begin{mdframed}\begin{lstlisting}
const <datatype> <NAME_OF_CONSTANT> = <value>;
\end{lstlisting}\end{mdframed}
\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
// Дефиниране на константа от тип "int"\ с име "MAX\_AGE"\ със стойност 120
const int MAX_AGE = 120;
// Дефиниране на константа от тип "double"\ с име "PI"\ със стойност 3.14159
const double PI = 3.14159;
// Дефиниране на константа от тип "string"\ с име "GREETING"
// със стойност "Greetings!"
const string GREETING = "Greetings!";
\end{lstlisting}\end{mdframed}
\begin{enumerate}
    \item[2.] Използване на константи\\Константите могат да се използват в програмата по същия начин като променливите.
\end{enumerate}
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
const int MAX_AGE = 120;
int age = 25;
if (age > MAX_AGE) {
    cout << "Invalid age!" << endl;
}
\end{lstlisting}\end{mdframed}

\subsection{Подпрограми (Функции)}
Функциите в \cpp са блокове от код, които изпълняват конкретна задача. Те могат да приемат аргументи и връщат резултат.

\subsubsection{Функции с тип}
Функциите с тип връщат резултат от конкретен тип.

\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
int sum(int a, int b) {
    return a + b;
}
\end{lstlisting}\end{mdframed}
В този пример функцията \code{sum} приема два целочислени аргумента (\code{a} и \code{b}) и връща цяло число (\code{int}), което е сумата на двата аргумента.

\subsubsection{Void функции}
\code{Void} функциите не връщат резултат. Те се използват за изпълнение на действия, които не връщат стойност.

\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
void printHello() {
    cout << "Hello, world!" << endl;
}
\end{lstlisting}\end{mdframed}
В този пример функцията \code{printHello} не връща резултат. Тя просто извежда текст на конзолата.

\subsubsection{Аргументи на функцията}
Аргументите на функцията са стойности, които се предават на функцията при викането й.
\pagebreak
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
int sum(int a, int b) {
    return a + b;
}

int main() {
    int result = sum(10, 20); // Предаване на аргументите 10 и 20
    cout << result << endl; // Извеждане на резултата (30)
    return 0;
}
\end{lstlisting}\end{mdframed}
В този пример функцията \code{sum} приема два целочислени аргумента (\code{a} и \code{b}). При викането й в \code{main} функцията, се предават стойностите \code{10} и \code{20} за \code{a} и \code{b} съответно.

\subsubsection{Предаване по стойност}
При предаване по стойност, на функцията се предава копия на аргументите.

\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 10;
    int y = 20;
    swap(x, y); // Предаване по стойност
    cout << x << " " << y << endl; // Извеждане на "10 20"
    return 0;
}
\end{lstlisting}\end{mdframed}
В този пример, функцията \code{swap} не модифицира оригиналните стойности на \code{x} и \code{y}, защото работи с копия.

\subsubsection{Предаване по препратка}
При предаване по препратка, на функцията се предава адреса на аргументите.
\pagebreak
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}
    
int main() {
    int x = 10;
    int y = 20;
    swap(x, y); // Предаване по препратка (директен адрес)
    cout << x << " " << y << endl; // Извеждане на "20 10"
    return 0;
}
\end{lstlisting}\end{mdframed}
В този пример, функцията swap модифицира оригиналните стойности на \code{x} и \code{y}, защото работи с адресите им.
\subsubsection{Рекурсия}
Рекурсията е техника, при която функция се вика сама себе си.

\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
\end{lstlisting}\end{mdframed}
В този пример функцията \code{factorial} изчислява факториела на число чрез рекурсивната формула $n! = n \cdot (n-1)!$.

\textbf{Важно}: Рекурсията трябва да има базов случай, който прекратява рекурсивните викания. В противен случай програмата изпада в безкраен цикъл, докато не се стигне до момента, в който паметта, нужна за запазване на променливите и информацията, надвиши разпределената за процеса памет в стека (Stack overflow).

\subsubsection{Lambda функции}
Lambda функциите са анонимни функции, които могат да се дефинират и използват в една линия код.

\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
auto sum = [](int a, int b) {
    return a + b;
};
int result = sum(10, 20); // Извикване на lambda функцията
\end{lstlisting}\end{mdframed}
В този пример lambda функцията \code{sum} приема два целочислени аргумента (\code{a} и \code{b}) и връща цяло число (\code{int}), което е сумата на двата аргумента.

\subsection{Атрибути}
Атрибутите в \cpp са специални ключови думи, които модифицират поведението на променливи, функции, класове и други елементи на кода. Те определят важни характеристики, като обхват, вид, жизнен цикъл, достъп и други.

\subsubsection{Const}
Атрибутът \code{const} определя, че стойността на променливата не може да се променя след инициализирането й. \code{Const} гарантира, че стойността няма да се промени неволно, подобрявайки безопасността на кода.

\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
const int PI = 3.14159;
\end{lstlisting}\end{mdframed}
В този пример \code{PI} е константа с стойност \code{3.14159}.
\subsubsection{Static}
Атрибутът \code{static} определя, че променливата е статична. Статичните променливи съществуват само в рамките на файла, в който са дефинирани. Инициализират се само веднъж при първото викане на файла и живеят цял живот на програмата. Споделят се между всички функции в файла.
\pagebreak
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{mdframed}\begin{lstlisting}
static int count = 0;
\end{lstlisting}\end{mdframed}
В този пример \code{count} е статична променлива.

\subsubsection{Extern}
Атрибутът \code{extern} определя, че променливата е дефинирана в друг файл. Атрибутът \code{extern} не инициализира променливата, само указва, че тя съществува някъде друде.

\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
extern int count;
\end{lstlisting}\end{mdframed}
В този пример \code{count} е променлива, която е дефинирана в друг файл.

\subsubsection{Volatile}
Атрибутът \code{volatile} указва, че стойността на променливата може да се променя външно, без да се вижда от компилатора. Атрибутът \code{volatile} предотвратява компилатора да оптимизира кода, който работи с променливата. Използва се за променливи, чиято стойност може да се промени от външни фактори, като прекъсвания, таймери или други процеси.

\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
volatile int counter;
\end{lstlisting}\end{mdframed}
В този пример \code{counter} е променлива, чиято стойност може да се променя от външен код.

\subsubsection{Register}
Атрибутът \code{register} препоръчва на компилатора да съхранява променливата в регистър на процесора. Атрибутът \code{register} е само препоръка. Не гарантира, че компилаторът ще съхрани променливата в регистър. Използва се за често използвани променливи, за да се подобри ефективността.
\pagebreak
\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
register int i;
\end{lstlisting}\end{mdframed}
В този пример \code{i} е променлива, която компилаторът може да съхрани в регистър.

\subsubsection{Auto}
Атрибутът \code{auto} позволява на компилатора да определи типа на променливата автоматично. \code{Auto} улеснява кода, когато типът на променливата е ясен от инициализацията.

\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
auto x = 10;
\end{lstlisting}\end{mdframed}
В този пример \code{x} е променлива с тип \code{int}, определен автоматично от компилатора.

\section{Стандартен конзолен I/O в \cpp}
В тази част ще разгледаме как се работи със системната конзола за стандартно въвеждане и извеждане на информация в \cpp и как да манипулираме получените данни от конзолата, а именно да обработваме информация от \code{string} данните.
\subsection{Работа със системната конзола}
В \cpp за стандартно въвеждане и извеждане на данни се използва пакетът \code{<iostream>}. Той предоставя обекти, които улесняват взаимодействието с потребителя и файловете.

\begin{itemize}
    \item \code{std::cin} - Стандартен входен поток (конзола).
    \item \code{std::cout} - Стандартен изходен поток (конзола).
    \item \code{std::cerr} - Стандартен изходен поток за грешки (конзола).
    \item \code{std::endl} - \code{'\bs n'} (Нов ред).
\end{itemize}

Операторите \code{>}\code{>} и \code{<}\code{<} са специални оператори, които улесняват взаимодействието с \code{cin} и \code{cout}.

\begin{itemize}
    \item \code{>}\code{>} - Операторът за въвеждане.
    \item \code{<}\code{<} - Операторът за извеждане.
\end{itemize}
\pagebreak
\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}{C++}
#include <iostream>

int main() {
    int number;
    std::cout << "Insert a number: "; // Извеждане на текст на конзолата
    std::cin >> number; // Въвеждане на число от конзолата
    // Извеждане на числото на конзолата
    std::cout << "The inserted number is: " << number << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}

\subsubsection{Пакет \code{<iomanip>}}
Пакетът \code{<iomanip>} предоставя методи за манипулиране на входящите и изходящите данни.

\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <iomanip>

int main() {
    double number = 123.456789;
    std::cout << "The number is: " 
        << std::setprecision(4) << number << std::endl;
    std::cout << "The number is: " 
        << std::setw(10) << number << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}
В този пример:

\code{std::setprecision(4)} - ограничава точните цифри на числото до 4.

\code{std::setw(10)} - задава ширина на полето за извеждане на числото на 10 символа.

\begin{itemize}
    \item[Резултат:]
\end{itemize} 
\vspace{-4pt}\begin{mdframed}\begin{lstlisting}[language=bash]
The number is: 123.5
The number is:      123.5
\end{lstlisting}\end{mdframed}

\subsubsection{Допълнителни методи}
Пакетът \code{<iomanip>} предлага много други методи за форматиране на входящите и изходящите данни.

Някои от тях са:
\begin{itemize}
    \item \code{std::fixed} - Извежда числа с фиксирана точка.
    \item \code{std::scientific} - Извежда числа в научен запис.
    \item \code{std::left} - Подравнява текста вляво.
    \item \code{std::right} - Подравнява текста вдясно.
\end{itemize}

\subsection{Работа със \code{string} данни}\label{sec:string}
В \cpp класът \code{std::string} предоставя мощен инструмент за работа с текстови низове. Той осигурява множество функции за манипулиране, сравняване, търсене и модифициране на текстови низове.

\subsubsection{Инициализиране на \code{string}}
Има няколко начина за инициализиране на string обект:

Празен \code{string}:
\begin{mdframed}\begin{lstlisting}
std::string text; // Инициализира празен string
\end{lstlisting}\end{mdframed}

С текстова константа:
\vspace{-4pt}\begin{mdframed}\begin{lstlisting}
// Инициализира string с текстова константа
std::string text = "Hello, world!";
\end{lstlisting}\end{mdframed}

С друг \code{string}:
\vspace{-4pt}\begin{mdframed}\begin{lstlisting}
std::string text1 = "Hello, ";
// Инициализира string с конкатенация на други string-ове
std::string text2 = text1 + "world!";
\end{lstlisting}\end{mdframed}

С масив от символи:
\vspace{-4pt}\begin{mdframed}\begin{lstlisting}
char text[] = "Hello, world!"; // string в стил C
// Инициализира string в стил C++ с масив от символи
std::string textString(text);
\end{lstlisting}\end{mdframed}

\begin{center}\textbf{Основни функции}\end{center}

\newcolumntype{E}{ >{\centering\arraybackslash} m{8cm} }
\begin{center}\begin{tabular}{|E|C|}
    \hline
    \code{getline(istream\& is, string\& str, char delim)} & \vspace{3pt}Въвежда редове от стандартен вход (\code{cin}) в \code{string} обект. \code{delim} определя разделителя на редовете. По подразбиране разделителят е \code{'\bs n'} (нов ред).\vspace{3pt}\\\hline
    \code{length()} & \vspace{3pt}Връща дължината на текстовия низ.\vspace{3pt}\\\hline
    \code{at(size\_t pos)} & \vspace{3pt}Връща символа на позиция \code{pos} в текстовия низ.\vspace{3pt}\\\hline
    \code{append(const string\& str)}\hfil \code{"}\code{+"} & \vspace{3pt}Добавя текстов низ \code{str} към края на текстовия низ.\vspace{3pt}\\\hline
    \code{compare(const string\& str)}\hfil \code{"}\code{=="} & \vspace{3pt}Сравнява текстовия низ с \code{str}. Връща \code{0}, ако низовете са равни; \code{<0}, ако текстовият низ е по-къс от \code{str}; \code{>0}, ако текстовият низ е по-дълъг от \code{str}.\vspace{3pt}\\\hline
    \code{substr(size\_t pos, size\_t len)} & \vspace{3pt}Връща подниз от текстовия низ, започвайки от позиция \code{pos} и с дължина \code{len}.\vspace{3pt}\\\hline
    \code{find(const string\& str, size\_t pos)} & \vspace{3pt}Търси подниз \code{str} в текстовия низ, започвайки от позиция \code{pos}. Връща позицията на първото намиране на \code{str}, ако е намерен, иначе връща \code{string::npos}.\vspace{3pt}\\\hline
    \code{replace(size\_t pos, size\_t len, const string\& str)} & \vspace{3pt}Заменя подниз от текстовия низ, започвайки от позиция \code{pos} и с дължина \code{len} с \code{str}.\vspace{3pt}\\\hline
    \code{insert(size\_t pos,\hfil const string\& str)} & \vspace{3pt}Вмъква \code{str} в текстовия низ на позиция \code{pos}.\vspace{3pt}\\\hline
    \code{erase(size\_t pos, size\_t len)} & \vspace{3pt}Премахва подниз от текстовия низ, започвайки от позиция \code{pos} и с дължина \code{len}.\vspace{3pt}\\\hline
\end{tabular}\end{center}
\pagebreak

\textbf{Примери:}
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <string>

using namespace std;

int main() {
    string text = "Hello, world!";

    // Въвеждане на текст от конзолата
    cout << "Insert text: ";
    getline(cin, text);

    // Извеждане на дължината на текста
    cout << "The length of the text is: " << text.length() << endl;

    // Извеждане на символа на позиция 5
    cout << "The character at position 5 is: "
        << text.at(5) << endl;

    // Добавяне на текст към края
    text.append(" How are you?");
    cout << "The text is: " << text << endl;

    // Сравняване на два текста
    string otherText = "Hello, world!";
    if (text.compare(otherText) == 0) {
        cout << "The texts are equal." << endl;
    } else {
        cout << "The texts are not equal." << endl;
    }

    // Извеждане на подниз
    cout << "The substring from position 7 to the end is: "
        << text.substr(7) << endl;

    // Търсене на подниз
    size_t pos = text.find("world");
    if (pos != string::npos) {
        cout << "The substring \"world\" was found at position: "
            << pos << endl;
    } else {
        cout << "The substring \"world\" wasn't found." << endl;
    }
\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[firstnumber=last]
    
    // Замяна на подниз
    text.replace(7, 5, "universe");
    cout << "The text is: " << text << endl;

    // Вмъкване на текст
    text.insert(7, "beautiful ");
    cout << "The text is: " << text << endl;

    // Премахване на текст
    text.erase(7, 10);
    cout << "The text is: " << text << endl;

    return 0;
}
\end{lstlisting}\end{mdframed}

\textbf{Резултат:} (Примерен входен текст: Hello, world!)
\begin{mdframed}\begin{lstlisting}[language=bash]
Insert text: >>Hello, world!
The length of the text is: 13
The character at position 5 is: ,
The text is: Hello, world! How are you?
The texts are not equal.
The substring from position 7 to the end is: world! How are you?
The substring "world" was found at position: 7
The text is: Hello, universe! How are you?
The text is: Hello, beautiful universe! How are you?
The text is: Hello, universe! How are you?
\end{lstlisting}\end{mdframed}

\section{Структуриране на \cpp програма}
\subsection{Директиви към предпроцесора}
Предпроцесорът е ключов компонент в \cpp компилационния процес, който обработва кода преди да бъде компилиран. Той изпълнява специални инструкции, наречени директиви, които променят структурата на кода преди да бъде предаден на компилатора.

Най-често използваните директиви към предпроцесора в \cpp са:

\subsubsection{\#include}
\code{\#include} е най-често използваната директива. Тя включва съдържанието на друг файл в текущия файл. Това е ключово за организирането на \cpp код в отделни файлове, например за дефиниране на функции или класове в отделни \code{.h} файлове.

Стандартни файлове: \code{\#include} се използва за включване на стандартни библиотеки, например:
\begin{mdframed}\begin{lstlisting}
// Включва стандартния header файл за входящи и изходящи операции
#include <iostream>
\end{lstlisting}\end{mdframed}

Потребителски файлове: \code{\#include} се използва за включване на файлове, създадени от програмиста, например:
\begin{mdframed}\begin{lstlisting}
#include "my_functions.h" // Включва файл с дефиниции на функции
\end{lstlisting}\end{mdframed}

\subsubsection{\#define}
\code{\#define} се използва за дефиниране на константи и макроси. Константите са променливи, чиято стойност не може да бъде променена след дефинирането им. Макросите са блокове код, които се заменят с дефинираното съдържание по време на предпроцесорната обработка.

Дефиниране на константи:
\begin{mdframed}\begin{lstlisting}
#define PI 3.14159 // Дефинира константа PI
#define MAX\_SIZE 100 // Дефинира константа MAX\_SIZE
\end{lstlisting}\end{mdframed}

Дефиниране на макроси:
\begin{mdframed}\begin{lstlisting}
#define SQUARE(x) (x * x) // Дефинира макрос за изчисляване на квадрат
// Дефинира макрос за извеждане на съобщение
#define PRINT_MESSAGE(msg) std::cout << msg << std::endl;
\end{lstlisting}\end{mdframed}

\subsubsection{\#undef}
\code{\#undef} се използва за премахване на предишно определение на константа или макрос.

\begin{mdframed}\begin{lstlisting}
#undef PI // Премахва определението на PI
\end{lstlisting}\end{mdframed}

\subsubsection{\#ifdef, \#ifndef, \#else, \#endif}
Тези директиви се използват за условно компилиране на код. Тоест, определени части от кода се компилират само ако е изпълнено определено условие.

\begin{itemize}
    \item[--] \code{\#if} - Позволява условно компилиране на код въз основа на резултата от препроцесорно условие.
    Това условие може да бъде дефинирана константа (\code{\#if defined(MY\_CONSTANT)}), макрос (\code{\#if SQUARE(5) == 25}),
    оператори за сравнение (\code{\#if 10 > 5}), логически оператори (\code{\#if defined(DEBUG) \&\& defined(RELEASE)}).
    \item[--] \code{\#ifdef} - Проверява дали константа или макрос е дефиниран.
    \item[--] \code{\#ifndef} - Проверява дали константа или макрос не е дефиниран.
    \item[--] \code{\#else} - Изпълнява се, ако условието в \code{\#if}, \code{\#ifdef} или \code{\#ifndef} не е изпълнено.
    \item[--] \code{\#endif} - Завършва блока, дефиниран от \code{\#if}, \code{\#ifdef}, \code{\#ifndef} или \code{\#else}.
\end{itemize}

\begin{itemize}\item [Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#define SIX 6

#if defined(SIX)
    #pragma message("The constant SIX is defined.")
#endif

#if (SIX > 5)
    #pragma message("6 is greater than 5.")
#endif

#undef SIX

#ifdef SIX
    // Този ред ще се компилира само ако е дефинирана константата SIX
    #pragma message("The constant SIX is defined.")
#else
    // Този ред ще се компилира само ако константата SIX не е дефинирана
    #pragma message("The constant SIX is not defined.")
#endif
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item [Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language=bash]
>| The constant SIX is defined.
>| 6 is greater than 5.
>| The constant SIX is not defined.
\end{lstlisting}\end{mdframed}
\subsubsection{\#pragma}
\code{\#pragma} е директива, която предоставя инструкции на компилатора. Тези инструкции са специфични за компилатора и могат да се различават между различните компилатори.

\code{\#pragma message(STRING)} - Извежда съобщения в конзолата по време на компилирането. Това е полезно при дебъгване на компилаторни проблеми.
\begin{mdframed}\begin{lstlisting}
// Изписва съобщението "Hello, world!"\ редом с другите съобщения от компилатора
#pragma message("Hello, world!");
\end{lstlisting}\end{mdframed}

\code{\#pragma once} - Предотвратява многократно включване на header файл. Това е полезно за предотвратяване на грешки при компилация, когато един и същ header файл се включва многократно.
\begin{mdframed}\begin{lstlisting}
#pragma once // Предотвратява многократно включване на header файл
\end{lstlisting}\end{mdframed}

\subsubsection{\#error}
\code{\#error} е директива, която генерира грешка по време на компилация. Това е полезно за сигнализиране на грешки, които не могат да бъдат открити от компилатора.

\begin{itemize}\item [Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#if !defined(MY_CONSTANT)
    #error "The constant MY_CONSTANT is not defined!"
#endif
\end{lstlisting}\end{mdframed}
В този пример, ако константата \code{MY\_CONSTANT} не е дефинирана, компилаторът ще генерира грешка с текст \code{"The constant MY\_CONSTANT is not defined!"}.

\subsection{Области на имената}

\chapter{Типове данни}
\section{Типове данни за цели и реални числа}
\section{Типове данни за символ и низ}
За повече информация за работа със \code{string} обекти, виж (\ref{sec:string})
\section{Логически данни}

\chapter{Конструкции за поточен контрол}
\section{Конструкции за разклонение}
!!  Ternary operator
\section{Конструкции за цикъл}
\section{Конструкции за прекъсване}

\chapter{Съставни типове данни}
\section{Масиви}
\section{Структури}
\section{Класове}
\section{Обединения}
\section{Изброяване}
\section{Колекции}

\chapter{Манипулиране на паметта}
\section{Указатели}
\section{Референции}
\section{Адресна аритметика}
\section{Динамично и статично разпределяне на паметта}

\chapter{Алгоритми}

\chapter*{Реализация на софтуерно приложение "\dots"}
\addcontentsline{toc}{chapter}{Реализация на софтуерно приложение}

\end{document}