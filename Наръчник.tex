\documentclass[oneside]{book}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[fontsize=12pt]{scrextend}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,bulgarian]{babel}
\usepackage{hyperref}
\usepackage{amsmath,amsthm,amsfonts}
\usepackage[framemethod=tikz]{mdframed}
\usepackage{array}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\definecolor{codegreen}{rgb}{0,0.85,0}
\definecolor{codegray}{rgb}{0.65,0.65,0.65}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.2,0.2,0.25}

\mdfdefinestyle{bg}{
    backgroundcolor=backcolour,
    leftmargin=0pt,
    hidealllines=true,
    innerleftmargin=2pt,
    innerrightmargin=2pt,
    innertopmargin=-4pt,
    innerbottommargin=-4pt
}
\mdfsetup{style=bg}

\lstdefinestyle{mystyle}{
    language=C++,
    texcl=true,
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegray},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codegreen},
    basicstyle=\ttfamily\footnotesize\color{white},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=6pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    extendedchars=\true,
    inputencoding=utf8x
}
\lstset{style=mystyle}

\newcommand*{\code}[1]{\texttt{#1}}
\newcommand*{\cpp}{\texttt{C++}\ }
\newcommand*{\bs}{\textbackslash}

\title{Наръчник\\Как се научих да програмирам на \cpp
с помощта на изкуствен интелект}
\author{Шенер Юмер, 2401321044}
\date{Използван LLM: Aria}

\begin{document}
\maketitle
\tableofcontents
\newpage

\chapter*{Предговор}
\addcontentsline{toc}{chapter}{Предговор}
Здравей, скъпи читателю!

Добре дошъл в твоето пътуване през света на програмирането, пътуване,
което започна с любопитство и ще завърши с осъзнаването, че дори изкуственият
интелект може да бъде учител.

Тази книга е както проектна работа, така и плод на моя опит в изучаването на \cpp,
език, който е едновременно мощен и взискателен. С помощта на изкуствения интелект
Aria от Opera GX, аз се научих да разбирам абстрактни концепции, да решавам сложни
проблеми и да създавам код, който работи.

На тези страници ще ти покажа уроците, които научих от Aria, и стъпка по стъпка ще те
науча как и ти да овладееш тънкостите на езика \cpp. Ще ти докажа, че чрез помощта на 
изкуственият интелект можете да извлечеш изключително много информация за изучаването
на програмни езици и по този начин да се вдъхновиш да се впуснеш в света
на програмирането.

Нека това пътуване те вдъхнови да преоткриеш собствения си потенциал
и да осъзнаеш, че нищо не е невъзможно!

\chapter{Въведение}
Добре дошли в света на \cpp! Този език за програмиране е истински гигант, който стои в основата на безброй приложения, игри и технологии, които използваме всеки ден. \cpp е език, който ви дава мощта да създавате сложни и ефективни програми, да контролирате хардуера на компютъра си и да реализирате най-смелите си идеи. 

Но \cpp не е за начинаещи. Той е мощен и гъвкав, но е и сложен и изисква задълбочено разбиране.  

Какво прави \cpp толкова специален?
\begin{itemize}
    \item[--] Обектно-ориентирано програмиране - \cpp е език, който ви позволява да структурирате програмите си около обекти, които съдържат данни и функции. Това е като да създадете симулация на реалния свят в код, където всеки обект е отделен елемент с собствени характеристики и поведение.
    \item[--] Висока производителност - \cpp е известен с ефективността си. Той ви дава пълен контрол над ресурсите на компютъра и ви позволява да създавате приложения, които работят бързо и ефективно. 
    \item[--] Гъвкавост - \cpp е гъвкав език, който ви позволява да разработвате разнообразни приложения, от операционни системи и игри до приложения за мобилни устройства. 
    \item[--] Широко разпространен - \cpp е широко разпространен език, който се използва от милиони програмисти по целия свят. Това означава, че ще имате лесен достъп до ресурси, общности и поддръжка.
\end{itemize}

Защо да се учите на \cpp?
\begin{itemize}
    \item[--] Мощни приложения - \cpp ви дава мощта да създавате комплексни и ефективни приложения, които могат да решават трудни задачи. 
    \item[--] Дълбоко разбиране - \cpp ви учи да разбирате как работи компютърът и как да управлявате ресурсите му. 
    \item[--] Отворена врата към нови възможности - \cpp е отворена врата към широк спектър от професионални възможности. 
\end{itemize}

В тази книга ще ви запознаем с основите на \cpp и ще ви покажем как да създавате свои собствени програми. Пригответе се за вълнуващо пътешествие в света на програмирането! 

\section{Първи стъпки в \cpp}
В тази глава ще се запознаем с основите на \cpp, като започнем с компилация, компилиране и изпълнение на програми.

\subsection{Компилация и изпълнение}
\cpp е компилиран език. Това означава, че кодът, който пишете, трябва да бъде преведен на машинно разбираем език, преди да може да се изпълни.

Компилацията е процес, който превръща изходния код (текстовият файл, който вие пишете) в изпълним файл.
Изпълним файл е файл, който може да се изпълни от компютъра.

За да компилирате и изпълните \cpp програма, ще ви е необходим компилатор.
Компилатор е програма, която превежда изходния код на \cpp в изпълним файл.

\subsection{Как да компилираме и изпълним програма?}
Ето стъпките, които трябва да следвате, за да компилирате и изпълните \cpp програма:

\begin{enumerate}
    \item[--] Създайте нов текстов файл с разширение .cpp.
    \item[--] Напишете \cpp кода си в този файл.
    \item[--] Отворете командния ред (или терминал) и отидете до директорията, където е вашият текстов файл.
    \item[--] Въведете следната команда, за да компилирате програмата:\\
        \code{g++ име\_на\_файла.cpp -o име\_на\_изпълним\_файл}
    \item[--] Въведете следната команда, за да изпълните програмата:\\
        \code{./име\_на\_изпълним\_файл}
\end{enumerate}

Пример:

Ако вашият файл се казва \code{hello.cpp} и искате да създадете изпълним файл \code{hello}, тогава трябва да въведете следните команди:

\begin{mdframed}\begin{lstlisting}[language={}]
g++ hello.cpp -o hello
./hello
\end{lstlisting}\end{mdframed}

\subsection{Имплементиране на български език в \cpp}
За да използваме български език в кода на \cpp и в конзолата, трябва първо да
зададем локализацията на проекта:
\begin{mdframed}\begin{lstlisting}
#include <locale>

int main() {
    setlocale(LC_ALL, "Bulgarian");
        // Локализация на кирилицата в проекта

    return 0;
}
\end{lstlisting}\end{mdframed}

\code{\#include <locale>} - Тази линия включва библиотеката \code{locale}, която ни дава достъп до функции за локализация на езици.

\code{setlocale(LC\_ALL, "Bulgarian");} - Стандартна функция за локализация на български език.

\subsection{Първата ни програма}
Ето пример за проста \cpp програма, която извежда текст на екрана:
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <locale>

int main() {
    setlocale(LC_ALL, "Bulgarian");

    std::cout << "Hello, world!" << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}

\code{\#include <iostream>} - Тази линия включва библиотеката \code{iostream}, която ни дава достъп до функции за вход и изход.

\code{int main()} - Тази линия дефинира главната функция на програмата. Всички \cpp програми трябва да имат главна функция.

\code{std::cout <}\code{< "Hello, world!"}\code{ <}\code{< std::endl;} - Тази линия извежда текста\\\code{"Hello, world!"} на екрана.

\code{return 0;} - Тази линия завършва изпълнението на програмата.

\section{Ключови елементи на синтаксиса и семантиката на \cpp}
\subsection{Ключови думи}
Ключовите думи в \cpp са резервирани думи, които имат специално значение за компилатора. Те не могат да се използват като имена на променливи, функции или други идентификатори.

\newcolumntype{C}{ >{\centering\arraybackslash} m{6cm} }
\newcolumntype{D}{ >{\centering\arraybackslash} m{5cm} }
\begin{center}\begin{tabular}{|C|D|}
    \hline Ключова дума    &   Описание\\\hline\hline
    \vspace{3pt}\code{int, float, double, char, bool, void, auto, const, constexpr, decltype}\vspace{3pt} & Типове данни\\\hline
    \vspace{3pt}\code{if, else, else if, switch, case, default, break, continue, goto}\vspace{3pt} & Условни оператори\\\hline
    \vspace{3pt}\code{for, while, do while, break, continue}\vspace{3pt} & Цикли\\\hline
    \vspace{3pt}\code{return, sizeof, new, delete, nullptr, this}\vspace{3pt} & Оператори\\\hline
    \vspace{3pt}\code{namespace, using, struct, class, enum, union, template, typename, friend, operator}\vspace{3pt} & Организъм на кода\\\hline
    \vspace{3pt}\code{public, private, protected, static, virtual, override, final, explicit}\vspace{3pt} & Модификатори за достъп\\\hline
    \vspace{3pt}\code{inline, extern, volatile, mutable, register}\vspace{3pt} & Модификатори за компилация\\\hline
    \vspace{3pt}\code{try, catch, throw, noexcept}\vspace{3pt} & Обработка на изключения\\\hline
\end{tabular}\end{center}

Ключовите думи се използват в \cpp код, за да се определят типове данни, структури, класове, функции и други елементи на програмата.

\textbf{Пример:}
\begin{mdframed}\begin{lstlisting}
int main() {
    int a = 10; // int е ключова дума за дефиниране на целочислена променлива
    if (a > 5) { // if е ключова дума за условен оператор
        std::cout << "a is greater than 5" << std::endl;
    }
    return 0; // return е ключова дума за връщане на статус
}    
\end{lstlisting}\end{mdframed}

\subsection{Специални символи}
В \cpp езикът, освен букви, цифри и ключови думи, има и специални символи, които имат специално значение за компилатора. Тези символи се използват за определяне на оператори, разделителни символи, коментари и други елементи на кода.

\subsubsection{Оператори}
Операторите са специални символи, които извършват операции върху операнди.

\begin{itemize}
    \centering
    \item[] Аритметика
    \begin{itemize}
        \item[] \code{+} (събиране): \code{a + b}
        \item[] \code{-} (изваждане): \code{a - b}
        \item[] \code{*} (умножение): \code{a * b}
        \item[] \code{/} (деление): \code{a / b}
        \item[] \code{\%} (остатък от деление): \code{a \% b}
        \item[] \code{++} (увеличаване): \code{a++}
        \item[] \code{-}\code{-} (намаляване): \code{a-}\code{-}
    \end{itemize}
    \item[] Условни
    \begin{itemize}
        \item[] \code{==} (равенство): \code{a == b}
        \item[] \code{!=} (неравенство): \code{a != b}
        \item[] \code{>} (по-голямо): \code{a > b}
        \item[] \code{<} (по-малко): \code{a < b}
        \item[] \code{>=} (по-голямо или равно): \code{a >= b}
        \item[] \code{<=} (по-малко или равно): \code{a <= b}
        \item[] \code{\&\&} (логическо И): \code{a \&\& b}
        \item[] \code{||} (логическо ИЛИ): \code{a || b}
        \item[] \code{!} (логическо НЕ): \code{!a}
        \item[] \code{?:} (тернарен условен оператор): \code{a ? b : c}
    \end{itemize}
    \item[] Битова аритметика
    \begin{itemize}
        \item[] \code{\&} (битово И): \code{a \& b}
        \item[] \code{|} (битово ИЛИ): \code{a | b}
        \item[] \code{\^{}} (битово ИЗКЛ. ИЛИ): \code{a \^{} b}
        \item[] \code{\~{}} (битово НЕ): \code{\~{}a}
        \item[] \code{<}\code{<} (ляво битово изместване): \code{a <}\code{< b}
        \item[] \code{>}\code{>} (дясно битово изместване): \code{a >}\code{> b}
    \end{itemize}
\end{itemize}

\subsubsection{Разделителни символи}
Разделителните символи се използват за разделяне на различни части на \cpp кода.

Пример:
\begin{itemize}
    \item[] \code{;} (точка и запетая): \code{int a = 10;}
    \item[] \code{,} (запетая): \code{int a = 10, b = 20;}
    \item[] \code{:} (двоеточие): \code{switch (a) \{ case 1: ...; \}}
    \item[] \code{::} (обхват на име): \code{std::cout}
    \item[] \code{.} (член на клас): \code{a.b}
    \item[] \code{->} (член на указател): \code{a->b}
    \item[] \code{[]} (индексиране): \code{a[b]}
    \item[] \code{()} (извикване на функция): \code{a()}
    \item[] \code{\{\}} (блокове код): \code{\{ ... \}}
\end{itemize}

\subsubsection{Коментари}
Коментарите са текст, който се игнорира от компилатора. Те се използват за обяснение на кода, добавяне на документация или деактивиране на част от кода.

Пример:
\begin{itemize}
    \item \code{//} (едноредов коментар):
\end{itemize}
\begin{mdframed}\begin{lstlisting}
// This is a single line comment.
\end{lstlisting}\end{mdframed}
\begin{itemize}
    \item \code{/* ... */} (многоредов коментар):
\end{itemize}
\begin{mdframed}\begin{lstlisting}
/*
 * This is a multiline comment.
 * It can extend on multiple lines.
 */
\end{lstlisting}\end{mdframed}

\subsection{Идентификатори}
Идентификаторите в \cpp са имена, които се използват за означаване на променливи, функции, класове, структури, изброявания, области на имена и други елементи на програмата.

\subsubsection{Правила за идентификатори}
Идентификаторите могат да се състоят от букви, цифри, подчертаване (\code{\_}). Първият символ на идентификатора не може да бъде цифра.
Ключовите думи не могат да се използват като идентификатори. Чувствителност към регистъра: \code{myVariable} и \code{MyVariable} са различни идентификатори.

\subsubsection{Примери за идентификатори}
\begin{itemize}
    \item[--] Променлива: \code{age, firstName, totalScore}
    \item[--] Функция: \code{calculateArea, printMessage, sortArray}
    \item[--] Клас: \code{Person, Car, Database}
    \item[--] Структура: \code{Point, Date, Time}
    \item[--] Изброяване: \code{Color, Status, Direction}
    \item[--] Област на имена: \code{std, myNamespace, utils}
\end{itemize}

\subsubsection{Препоръки за идентификатори}
Използвайте описателни имена, които отразяват целта на идентификатора. Използвайте \code{camelCase} или \code{snake\_case} за по-добра четимост.
Избягвайте къси и неясни имена. Не използвайте резервирани думи като идентификатори.

\subsubsection{Пример за код с идентификатори:}
\begin{mdframed}\begin{lstlisting}
#include <iostream>

using namespace std; // Дефиниране на областта на имената "std"

int main() {
    // Дефиниране на променлива с име "age"
    int age = 25;

    // Дефиниране на функция с име "printMessage"
    void printMessage(string message) {
    cout << message << endl;
    }

    // Извикване на функцията "printMessage"
    printMessage("Hello, world!");

    return 0;
}
\end{lstlisting}\end{mdframed}

\subsection{Литерали}
Литералите в \cpp са константни стойности, които се използват за представяне на данни в програмата. Те са директни представяния на данни, които се компилират директно в код.

\subsubsection{Видове литерали}
\cpp поддържа различни видове литерали, в зависимост от типа на данните:

\begin{itemize}
    \item Числови литерали:
    
    \begin{itemize}
        \item Цялочислени литерали:
        \item[] Десетични: \code{10, 25, -15}
        \item[] Осмоични: \code{012, 037} (започват с \code{0})
        \item[] Шестнадесетични: \code{0x1A, 0x2F} (започват с \code{0x})
        \item Дробни литерали: \code{3.14, 1.5e-2} (експоненциална нотация)
    \end{itemize}
    
    \item Символни литерали:
    
    \begin{itemize}
        \item Обикновени: \code{'a', 'B', '\%'}
        \item Escape последователности: \code{'\bs n', '\bs t', '\bs ''}
    \end{itemize}
    \item Текстови литерали:
    
    \begin{itemize}
        \item Обикновени: \code{"Здравей, свят!", "Hello, world!"}
        \item Raw string литерали: \code{R"(C:\bs Users\bs MyUser\bs Documents)"} (за запазване на escape последователности)
    \end{itemize}
    \item Булеви литерали: \code{true, false}
    \item Указателни литерали: \code{nullptr} (за празен указател)
\end{itemize}

\subsubsection{Пример за код с литерали}
\begin{mdframed}\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
    // Цялочислени литерали
    int age = 25;
    int octalNumber = 012;
    int hexNumber = 0x1A;

    // Дробни литерали
    double pi = 3.14;
    double smallNumber = 1.5e-2;

    // Символни литерали
    char character = 'A';
    char newline = '\n';

    // Текстови литерали
    string message = "Hello, world!";
    string path = R"(C:\Users\MyUser\Documents)";

    // Булеви литерали
    bool isTrue = true;
    bool isFalse = false;
\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[firstnumber=26]

    // Указателни литерали
    int* ptr = nullptr;

    return 0;
}
\end{lstlisting}\end{mdframed}

\subsection{Променливи и константи}
\subsubsection{Променливи}
Променливите в \cpp са имена, които се използват за съхраняване на данни в паметта. Тези данни могат да бъдат променяни по време на изпълнението на програмата.

\begin{enumerate}\item[1.] Дефиниране на променливи:\end{enumerate}
\begin{mdframed}\begin{lstlisting}
<datatype> <variable_name>;
\end{lstlisting}\end{mdframed}
\begin{itemize}\item[Пример:] \end{itemize}
\begin{mdframed}\begin{lstlisting}
int age; // Дефиниране на променлива от тип "int"\ с име "age"
double price; // Дефиниране на променлива от тип "double"\ с име "price"
string name; // Дефиниране на променлива от тип "string"\ с име "name"
\end{lstlisting}\end{mdframed}
\begin{enumerate}\item [2.] Инициализиране на променливи\\Инициализирането на променлива е процесът на присвояване на начална стойност при дефинирането.\end{enumerate}
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age = 25; // Инициализиране на променливата "age"\ със стойност 25
// Инициализиране на променливата "price"\ със стойност 19.99
double price = 19.99;
// Инициализиране на променливата "name"\ със стойност "Ivan"
string name = "Ivan";
\end{lstlisting}\end{mdframed}
\begin{enumerate}\item[3.] Използване на променливи\\След дефинирането и инициализирането, променливите могат да се използват в програмата.\end{enumerate}
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age = 25;
// Извеждане на стойността на променливата "age"
cout << "Your age is: " << age << endl;
\end{lstlisting}\end{mdframed}
\subsubsection{Константи}
Константите в \cpp са имена, които се използват за съхраняване на данни в паметта, но стойностите им не могат да се променят по време на изпълнението на програмата.

\begin{enumerate}\item[1.] Дефиниране на константи\\За да се дефинира константа, се използва ключовата дума \code{const}:\end{enumerate}
\begin{mdframed}\begin{lstlisting}
const <datatype> <NAME_OF_CONSTANT> = <value>;
\end{lstlisting}\end{mdframed}
\begin{itemize}\item[Пример:]\end{itemize} 
\begin{mdframed}\begin{lstlisting}
// Дефиниране на константа от тип "int"\ с име "MAX\_AGE"\ със стойност 120
const int MAX_AGE = 120;
// Дефиниране на константа от тип "double"\ с име "PI"\ със стойност 3.14159
const double PI = 3.14159;
// Дефиниране на константа от тип "string"\ с име "GREETING"
// със стойност "Greetings!"
const string GREETING = "Greetings!";
\end{lstlisting}\end{mdframed}
\begin{enumerate}\item[2.] Използване на константи\\Константите могат да се използват в програмата по същия начин като променливите.\end{enumerate}
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
const int MAX_AGE = 120;
int age = 25;
if (age > MAX_AGE) {
    cout << "Invalid age!" << endl;
}
\end{lstlisting}\end{mdframed}

\subsection{Подпрограми (Функции)}
Функциите в \cpp са блокове от код, които изпълняват конкретна задача. Те могат да приемат аргументи и връщат резултат.

\subsubsection{Функции с тип}
Функциите с тип връщат резултат от конкретен тип.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int sum(int a, int b) {
    return a + b;
}
\end{lstlisting}\end{mdframed}
В този пример функцията \code{sum} приема два целочислени аргумента (\code{a} и \code{b}) и връща цяло число (\code{int}), което е сумата на двата аргумента.

\subsubsection{Void функции}
\code{Void} функциите не връщат резултат. Те се използват за изпълнение на действия, които не връщат стойност.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
void printHello() {
    cout << "Hello, world!" << endl;
}
\end{lstlisting}\end{mdframed}
В този пример функцията \code{printHello} не връща резултат. Тя просто извежда текст на конзолата.

\subsubsection{Аргументи на функцията}
Аргументите на функцията са стойности, които се предават на функцията при викането й.
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int sum(int a, int b) {
    return a + b;
}

int main() {
    int result = sum(10, 20); // Предаване на аргументите 10 и 20
    cout << result << endl; // Извеждане на резултата (30)
    return 0;
}
\end{lstlisting}\end{mdframed}
В този пример функцията \code{sum} приема два целочислени аргумента (\code{a} и \code{b}). При викането й в \code{main} функцията, се предават стойностите \code{10} и \code{20} за \code{a} и \code{b} съответно.

\subsubsection{Предаване по стойност}
При предаване по стойност, на функцията се предава копия на аргументите.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 10;
    int y = 20;
    swap(x, y); // Предаване по стойност
    cout << x << " " << y << endl; // Извеждане на "10 20"
    return 0;
}
\end{lstlisting}\end{mdframed}
В този пример, функцията \code{swap} не модифицира оригиналните стойности на \code{x} и \code{y}, защото работи с копия.

\subsubsection{Предаване по препратка}
При предаване по препратка, на функцията се предава адреса на аргументите.
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}
    
int main() {
    int x = 10;
    int y = 20;
    swap(x, y); // Предаване по препратка (директен адрес)
    cout << x << " " << y << endl; // Извеждане на "20 10"
    return 0;
}
\end{lstlisting}\end{mdframed}
В този пример, функцията swap модифицира оригиналните стойности на \code{x} и \code{y}, защото работи с адресите им.
\subsubsection{Рекурсия}
Рекурсията е техника, при която функция се вика сама себе си.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
\end{lstlisting}\end{mdframed}
В този пример функцията \code{factorial} изчислява факториела на число чрез рекурсивната формула $n! = n \cdot (n-1)!$.

\textbf{Важно}: Рекурсията трябва да има базов случай, който прекратява рекурсивните викания. В противен случай програмата изпада в безкраен цикъл, докато не се стигне до момента, в който паметта, нужна за запазване на променливите и информацията, надвиши разпределената за процеса памет в стека (Stack overflow).

\subsubsection{Lambda функции}
Lambda функциите са анонимни функции, които могат да се дефинират и използват в една линия код.

\begin{itemize}\item[Пример:]\end{itemize} 
\begin{mdframed}\begin{lstlisting}
auto sum = [](int a, int b) {
    return a + b;
};
int result = sum(10, 20); // Извикване на lambda функцията
\end{lstlisting}\end{mdframed}
В този пример lambda функцията \code{sum} приема два целочислени аргумента (\code{a} и \code{b}) и връща цяло число (\code{int}), което е сумата на двата аргумента.

\subsection{Атрибути}
Атрибутите в \cpp са специални ключови думи, които модифицират поведението на променливи, функции, класове и други елементи на кода. Те определят важни характеристики, като обхват, вид, жизнен цикъл, достъп и други.

\subsubsection{Const}
Атрибутът \code{const} определя, че стойността на променливата не може да се променя след инициализирането й. \code{Const} гарантира, че стойността няма да се промени неволно, подобрявайки безопасността на кода.

\begin{itemize}\item[Пример:]\end{itemize} 
\begin{mdframed}\begin{lstlisting}
const int PI = 3.14159;
\end{lstlisting}\end{mdframed}
В този пример \code{PI} е константа с стойност \code{3.14159}.
\subsubsection{Static}
Атрибутът \code{static} определя, че променливата е статична. Статичните променливи съществуват само в рамките на файла, в който са дефинирани. Инициализират се само веднъж при първото викане на файла и живеят цял живот на програмата. Споделят се между всички функции в файла.
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
static int count = 0;
\end{lstlisting}\end{mdframed}
В този пример \code{count} е статична променлива.

\subsubsection{Extern}
Атрибутът \code{extern} определя, че променливата е дефинирана в друг файл. Атрибутът \code{extern} не инициализира променливата, само указва, че тя съществува някъде друде.

\begin{itemize}\item[Пример:]\end{itemize} 
\begin{mdframed}\begin{lstlisting}
extern int count;
\end{lstlisting}\end{mdframed}
В този пример \code{count} е променлива, която е дефинирана в друг файл.

\subsubsection{Volatile}
Атрибутът \code{volatile} указва, че стойността на променливата може да се променя външно, без да се вижда от компилатора. Атрибутът \code{volatile} предотвратява компилатора да оптимизира кода, който работи с променливата. Използва се за променливи, чиято стойност може да се промени от външни фактори, като прекъсвания, таймери или други процеси.

\begin{itemize}\item[Пример:]\end{itemize} 
\begin{mdframed}\begin{lstlisting}
volatile int counter;
\end{lstlisting}\end{mdframed}
В този пример \code{counter} е променлива, чиято стойност може да се променя от външен код.

\subsubsection{Register}
Атрибутът \code{register} препоръчва на компилатора да съхранява променливата в регистър на процесора. Атрибутът \code{register} е само препоръка. Не гарантира, че компилаторът ще съхрани променливата в регистър. Използва се за често използвани променливи, за да се подобри ефективността.
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize} 
\begin{mdframed}\begin{lstlisting}
register int i;
\end{lstlisting}\end{mdframed}
В този пример \code{i} е променлива, която компилаторът може да съхрани в регистър.

\subsubsection{Auto}
Атрибутът \code{auto} позволява на компилатора да определи типа на променливата автоматично. \code{Auto} улеснява кода, когато типът на променливата е ясен от инициализацията.

\begin{itemize}\item[Пример:]\end{itemize} 
\begin{mdframed}\begin{lstlisting}
auto x = 10;
\end{lstlisting}\end{mdframed}
В този пример \code{x} е променлива с тип \code{int}, определен автоматично от компилатора.

\section{Стандартен конзолен I/O в \cpp}
В тази част ще разгледаме как се работи със системната конзола за стандартно въвеждане и извеждане на информация в \cpp и как да манипулираме получените данни от конзолата, а именно да обработваме информация от \code{string} данните.
\subsection{Работа със системната конзола}
В \cpp за стандартно въвеждане и извеждане на данни се използва пакетът \code{<iostream>}. Той предоставя обекти, които улесняват взаимодействието с потребителя и файловете.

\begin{itemize}
    \item \code{std::cin} - Стандартен входен поток (конзола).
    \item \code{std::cout} - Стандартен изходен поток (конзола).
    \item \code{std::cerr} - Стандартен изходен поток за грешки (конзола).
    \item \code{std::endl} - \code{'\bs n'} (Нов ред).
\end{itemize}

Операторите \code{>}\code{>} и \code{<}\code{<} са специални оператори, които улесняват взаимодействието с \code{cin} и \code{cout}.

\begin{itemize}
    \item \code{>}\code{>} - Операторът за въвеждане.
    \item \code{<}\code{<} - Операторът за извеждане.
\end{itemize}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize} 
\begin{mdframed}\begin{lstlisting}{C++}
#include <iostream>

int main() {
    int number;
    std::cout << "Insert a number: "; // Извеждане на текст на конзолата
    std::cin >> number; // Въвеждане на число от конзолата
    // Извеждане на числото на конзолата
    std::cout << "The inserted number is: " << number << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}

\subsubsection{Пакет \code{<iomanip>}}
Пакетът \code{<iomanip>} предоставя методи за манипулиране на входящите и изходящите данни.

\begin{itemize}\item[Пример:]\end{itemize} 
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <iomanip>

int main() {
    double number = 123.456789;
    std::cout << "The number is: " 
        << std::setprecision(4) << number << std::endl;
    std::cout << "The number is: " 
        << std::setw(10) << number << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}
В този пример:

\code{std::setprecision(4)} - ограничава точните цифри на числото до 4.

\code{std::setw(10)} - задава ширина на полето за извеждане на числото на 10 символа.

\begin{itemize}\item[Резултат:]\end{itemize} 
\vspace{-4pt}\begin{mdframed}\begin{lstlisting}[language={}]
The number is: 123.5
The number is:      123.5
\end{lstlisting}\end{mdframed}

\subsubsection{Допълнителни методи}
Пакетът \code{<iomanip>} предлага много други методи за форматиране на входящите и изходящите данни.

Някои от тях са:
\begin{itemize}
    \item \code{std::fixed} - Извежда числа с фиксирана точка.
    \item \code{std::scientific} - Извежда числа в научен запис.
    \item \code{std::left} - Подравнява текста вляво.
    \item \code{std::right} - Подравнява текста вдясно.
\end{itemize}

\subsection{Работа със \code{string} данни}\label{sec:string}
В \cpp класът \code{std::string} предоставя мощен инструмент за работа с текстови низове. Той осигурява множество функции за манипулиране, сравняване, търсене и модифициране на текстови низове.

\subsubsection{Инициализиране на \code{string}}
Има няколко начина за инициализиране на string обект:

Празен \code{string}:
\begin{mdframed}\begin{lstlisting}
std::string text; // Инициализира празен string
\end{lstlisting}\end{mdframed}

С текстова константа:
\vspace{-4pt}\begin{mdframed}\begin{lstlisting}
// Инициализира string с текстова константа
std::string text = "Hello, world!";
\end{lstlisting}\end{mdframed}

С друг \code{string}:
\vspace{-4pt}\begin{mdframed}\begin{lstlisting}
std::string text1 = "Hello, ";
// Инициализира string с конкатенация на други string-ове
std::string text2 = text1 + "world!";
\end{lstlisting}\end{mdframed}

С масив от символи:
\vspace{-4pt}\begin{mdframed}\begin{lstlisting}
char text[] = "Hello, world!"; // string в стил C
// Инициализира string в стил \cpp с масив от символи
std::string textString(text);
\end{lstlisting}\end{mdframed}

\begin{center}\textbf{Основни функции}\end{center}

\newcolumntype{E}{ >{\centering\arraybackslash} m{8cm} }
\begin{center}\begin{tabular}{|E|C|}
    \hline
    \code{getline(istream\& is, string\& str, char delim)} & \vspace{3pt}Въвежда редове от стандартен вход (\code{cin}) в \code{string} обект. \code{delim} определя разделителя на редовете. По подразбиране разделителят е \code{'\bs n'} (нов ред).\vspace{3pt}\\\hline
    \code{length()} & \vspace{3pt}Връща дължината на текстовия низ.\vspace{3pt}\\\hline
    \code{at(size\_t pos)} & \vspace{3pt}Връща символа на позиция \code{pos} в текстовия низ.\vspace{3pt}\\\hline
    \code{append(const string\& str)}\hfil \code{"}\code{+"} & \vspace{3pt}Добавя текстов низ \code{str} към края на текстовия низ.\vspace{3pt}\\\hline
    \code{compare(const string\& str)}\hfil \code{"}\code{=="} & \vspace{3pt}Сравнява текстовия низ с \code{str}. Връща \code{0}, ако низовете са равни; \code{<0}, ако текстовият низ е по-къс от \code{str}; \code{>0}, ако текстовият низ е по-дълъг от \code{str}.\vspace{3pt}\\\hline
    \code{substr(size\_t pos, size\_t len)} & \vspace{3pt}Връща подниз от текстовия низ, започвайки от позиция \code{pos} и с дължина \code{len}.\vspace{3pt}\\\hline
    \code{find(const string\& str, size\_t pos)} & \vspace{3pt}Търси подниз \code{str} в текстовия низ, започвайки от позиция \code{pos}. Връща позицията на първото намиране на \code{str}, ако е намерен, иначе връща \code{string::npos}.\vspace{3pt}\\\hline
    \code{replace(size\_t pos, size\_t len, const string\& str)} & \vspace{3pt}Заменя подниз от текстовия низ, започвайки от позиция \code{pos} и с дължина \code{len} с \code{str}.\vspace{3pt}\\\hline
    \code{insert(size\_t pos,\hfil const string\& str)} & \vspace{3pt}Вмъква \code{str} в текстовия низ на позиция \code{pos}.\vspace{3pt}\\\hline
    \code{erase(size\_t pos, size\_t len)} & \vspace{3pt}Премахва подниз от текстовия низ, започвайки от позиция \code{pos} и с дължина \code{len}.\vspace{3pt}\\\hline
\end{tabular}\end{center}
\pagebreak

\textbf{Примери:}
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <string>

using namespace std;

int main() {
    string text = "Hello, world!";

    // Въвеждане на текст от конзолата
    cout << "Insert text: ";
    getline(cin, text);

    // Извеждане на дължината на текста
    cout << "The length of the text is: " << text.length() << endl;

    // Извеждане на символа на позиция 5
    cout << "The character at position 5 is: "
        << text.at(5) << endl;

    // Добавяне на текст към края
    text.append(" How are you?");
    cout << "The text is: " << text << endl;

    // Сравняване на два текста
    string otherText = "Hello, world!";
    if (text.compare(otherText) == 0) {
        cout << "The texts are equal." << endl;
    } else {
        cout << "The texts are not equal." << endl;
    }

    // Извеждане на подниз
    cout << "The substring from position 7 to the end is: "
        << text.substr(7) << endl;

    // Търсене на подниз
    size_t pos = text.find("world");
    if (pos != string::npos) {
        cout << "The substring \"world\" was found at position: "
            << pos << endl;
    } else {
        cout << "The substring \"world\" wasn't found." << endl;
    }
\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[firstnumber=last]
    
    // Замяна на подниз
    text.replace(7, 5, "universe");
    cout << "The text is: " << text << endl;

    // Вмъкване на текст
    text.insert(7, "beautiful ");
    cout << "The text is: " << text << endl;

    // Премахване на текст
    text.erase(7, 10);
    cout << "The text is: " << text << endl;

    return 0;
}
\end{lstlisting}\end{mdframed}

\textbf{Резултат:} (Примерен входен текст: Hello, world!)
\begin{mdframed}\begin{lstlisting}[language={}]
Insert text: >>Hello, world!
The length of the text is: 13
The character at position 5 is: ,
The text is: Hello, world! How are you?
The texts are not equal.
The substring from position 7 to the end is: world! How are you?
The substring "world" was found at position: 7
The text is: Hello, universe! How are you?
The text is: Hello, beautiful universe! How are you?
The text is: Hello, universe! How are you?
\end{lstlisting}\end{mdframed}

\section{Структуриране на \cpp програма}
\subsection{Директиви към предпроцесора}
Предпроцесорът е ключов компонент в \cpp компилационния процес, който обработва кода преди да бъде компилиран. Той изпълнява специални инструкции, наречени директиви, които променят структурата на кода преди да бъде предаден на компилатора.

Най-често използваните директиви към предпроцесора в \cpp са:

\subsubsection{\#include}
\code{\#include} е най-често използваната директива. Тя включва съдържанието на друг файл в текущия файл. Това е ключово за организирането на \cpp код в отделни файлове, например за дефиниране на функции или класове в отделни \code{.h} файлове.

Стандартни файлове: \code{\#include} се използва за включване на стандартни библиотеки, например:
\begin{mdframed}\begin{lstlisting}
// Включва стандартния header файл за входящи и изходящи операции
#include <iostream>
\end{lstlisting}\end{mdframed}

Потребителски файлове: \code{\#include} се използва за включване на файлове, създадени от програмиста, например:
\begin{mdframed}\begin{lstlisting}
#include "my_functions.h" // Включва файл с дефиниции на функции
\end{lstlisting}\end{mdframed}

\subsubsection{\#define}
\code{\#define} се използва за дефиниране на константи и макроси. Константите са променливи, чиято стойност не може да бъде променена след дефинирането им. Макросите са блокове код, които се заменят с дефинираното съдържание по време на предпроцесорната обработка.

Дефиниране на константи:
\begin{mdframed}\begin{lstlisting}
#define PI 3.14159 // Дефинира константа PI
#define MAX\_SIZE 100 // Дефинира константа MAX\_SIZE
\end{lstlisting}\end{mdframed}

Дефиниране на макроси:
\begin{mdframed}\begin{lstlisting}
#define SQUARE(x) (x * x) // Дефинира макрос за изчисляване на квадрат
// Дефинира макрос за извеждане на съобщение
#define PRINT_MESSAGE(msg) std::cout << msg << std::endl;
\end{lstlisting}\end{mdframed}

\subsubsection{\#undef}
\code{\#undef} се използва за премахване на предишно определение на константа или макрос.

\begin{mdframed}\begin{lstlisting}
#undef PI // Премахва определението на PI
\end{lstlisting}\end{mdframed}

\subsubsection{\#ifdef, \#ifndef, \#else, \#endif}
Тези директиви се използват за условно компилиране на код. Тоест, определени части от кода се компилират само ако е изпълнено определено условие.

\begin{itemize}
    \item[--] \code{\#if} - Позволява условно компилиране на код въз основа на резултата от препроцесорно условие.
    Това условие може да бъде дефинирана константа (\code{\#if defined(MY\_CONSTANT)}), макрос (\code{\#if SQUARE(5) == 25}),
    оператори за сравнение (\code{\#if 10 > 5}), логически оператори (\code{\#if defined(DEBUG) \&\& defined(RELEASE)}).
    \item[--] \code{\#ifdef} - Проверява дали константа или макрос е дефиниран.
    \item[--] \code{\#ifndef} - Проверява дали константа или макрос не е дефиниран.
    \item[--] \code{\#else} - Изпълнява се, ако условието в \code{\#if}, \code{\#ifdef} или \code{\#ifndef} не е изпълнено.
    \item[--] \code{\#endif} - Завършва блока, дефиниран от \code{\#if}, \code{\#ifdef}, \code{\#ifndef} или \code{\#else}.
\end{itemize}

\begin{itemize}\item [Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#define SIX 6

#if defined(SIX)
    #pragma message("The constant SIX is defined.")
#endif

#if (SIX > 5)
    #pragma message("6 is greater than 5.")
#endif

#undef SIX

#ifdef SIX
    // Този ред ще се компилира само ако е дефинирана константата SIX
    #pragma message("The constant SIX is defined.")
#else
    // Този ред ще се компилира само ако константата SIX не е дефинирана
    #pragma message("The constant SIX is not defined.")
#endif
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item [Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language={}]
>| The constant SIX is defined.
>| 6 is greater than 5.
>| The constant SIX is not defined.
\end{lstlisting}\end{mdframed}
\subsubsection{\#pragma}
\code{\#pragma} е директива, която предоставя инструкции на компилатора. Тези инструкции са специфични за компилатора и могат да се различават между различните компилатори.

\code{\#pragma message(STRING)} - Извежда съобщения в конзолата по време на компилирането. Това е полезно при дебъгване на компилаторни проблеми.
\begin{mdframed}\begin{lstlisting}
// Изписва съобщението "Hello, world!"\ редом с другите съобщения от компилатора
#pragma message("Hello, world!");
\end{lstlisting}\end{mdframed}

\code{\#pragma once} - Предотвратява многократно включване на header файл. Това е полезно за предотвратяване на грешки при компилация, когато един и същ header файл се включва многократно.
\begin{mdframed}\begin{lstlisting}
#pragma once // Предотвратява многократно включване на header файл
\end{lstlisting}\end{mdframed}

\subsubsection{\#error}
\code{\#error} е директива, която генерира грешка по време на компилация. Това е полезно за сигнализиране на грешки, които не могат да бъдат открити от компилатора.

\begin{itemize}\item [Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#if !defined(MY_CONSTANT)
    #error "The constant MY_CONSTANT is not defined!"
#endif
\end{lstlisting}\end{mdframed}
В този пример, ако константата \code{MY\_CONSTANT} не е дефинирана, компилаторът ще генерира грешка с текст \code{"The constant MY\_CONSTANT is not defined!"}.

\subsection{Области на имената}
Областите на имената (namespaces) в \cpp са механизъм за организиране на код в логически групи. Те са особено полезни за:

\begin{itemize}
    \item[] Избягване на конфликти на имена: В големи проекти, с множество модули и библиотеки, е възможно да се използват едни и същи имена за различни променливи, функции, класове и т.н. Областите на имената позволяват да се групират тези елементи, като им се дава уникално име за всяка група.
    \item[] Подобрена четливост: Те структурират кода, правейки го по-лесен за четене и разбиране.
    \item[] По-лесно управление на зависимостта: Могат да се използват за управление на зависимостта между различни части от кода.
\end{itemize}

\subsubsection{Дефиниране на области на имената}
В \cpp се дефинират области на имената с ключовата дума \code{namespace}. Синтаксисът е следният:

\begin{mdframed}\begin{lstlisting}
namespace <name_of_namespace> {
    // Дефиниции на променливи, функции, класове, т.н.
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
namespace MyNamespace {
    int x = 10;
    void printX() {
        std::cout << "x = " << x << std::endl;
    }
}
\end{lstlisting}\end{mdframed}

\subsubsection{Използване на области на имената}
За да се достъпи до елемент в област на имената, се използва операторът за обхват (\code{::}).
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int main() {
    MyNamespace::printX(); // Извиква функцията printX() от MyNamespace
    // Достъп до променливата x от MyNamespace
    std::cout << MyNamespace::x << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language={}]
x = 10
10
\end{lstlisting}\end{mdframed}

Могат да се дефинират области на имената, вложени една в друга.

Ключовата дума \code{using} може да се използва за импортиране на всички елементи от дадена област на имената.
Може да се използва за дефиниране на алиас за елемент от област на имената.

\begin{itemize}\item[Пример] за \code{using}:\end{itemize}
\begin{mdframed}\begin{lstlisting}
using namespace MyNamespace; // Импортиране на всички елементи от MyNamespace

int main() {
    printX(); // Извиква функцията printX() от MyNamespace
    // Достъп до променливата x от MyNamespace
    std::cout << x << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language={}]
x = 10
10
\end{lstlisting}\end{mdframed}

\chapter{Типове данни}
В \cpp типовете данни определят вида на данните, които можем да съхраняваме в променливи. Те ни казват каква информация може да се съхранява, как се интерпретира и какви операции могат да се извършват с нея.
\section{Типове данни за цели и реални числа}
В \cpp имаме няколко типа данни, които се използват за представяне на цели и реални числа:

Целочислени типове:
\begin{itemize}
    \item[--] \code{int}: Най-често използваният тип за цели числа. Обикновено заема 4 байта в паметта и може да съхранява числа в диапазона от -2,147,483,648 до 2,147,483,647.
    \item[--] \code{short}: Целочислени числа с по-малка големина, обикновено 2 байта. Диапазонът е от -32,768 до 32,767.
    \item[--] \code{long}: Целочислени числа с по-голяма големина, обикновено 4 байта. Диапазонът е от -2,147,483,648 до 2,147,483,647.
    \item[--] \code{long long}: Целочислени числа с още по-голяма големина, обикновено 8 байта. Диапазонът е от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807.
    \item[--] \code{unsigned int}: Неотрицателни цели числа. Диапазонът е (обикновено) от 0 до 4,294,967,295.
    \item[--] \code{unsigned short}: Неотрицателни цели числа с по-малка големина. Диапазонът е от 0 до 65,535.
    \item[--] \code{unsigned long}: Неотрицателни цели числа с по-голяма големина. Диапазонът е от 0 до 4,294,967,295.
    \item[--] \code{unsigned long long}: Неотрицателни цели числа с още по-голяма големина. Диапазонът е от 0 до 18,446,744,073,709,551,615.
\end{itemize}

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age = 25;
short year = 2023;
long population = 8000000;
long long bigNumber = 999999999999999999;
unsigned int counter = 0;
unsigned short port = 80;
unsigned long fileSize = 1024 * 1024 * 1024;
unsigned long long veryBigNumber = 18446744073709551615;
\end{lstlisting}\end{mdframed}

Типове с плаваща запетая:
\begin{itemize}
    \item[--] \code{float}: Числа с плаваща запетая с по-ниска прецизност, обикновено 4 байта.
    \item[--] \code{double}: Числа с плаваща запетая с по-висока прецизност, обикновено 8 байта.
    \item[--] \code{long double}: Числа с плаваща запетая с още по-висока прецизност, обикновено 16 байта.
\end{itemize}

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
float temperature = 25.5;
double pi = 3.141592653589793;
long double veryPreciseNumber = 3.1415926535897932384626433832795;
\end{lstlisting}\end{mdframed}

\section{Типове данни за символ и низ}
В \cpp имаме два основни типа данни, които се използват за представяне на текст:

\subsubsection{Символ (\code{char})}
Използва се за съхраняване на единичен символ, като буква, цифра или специален знак. Заема 1 байт в паметта.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
char letter = 'A';
char digit = '7';
char specialSymbol = '\%';
\end{lstlisting}\end{mdframed}

\subsubsection{Низ (като масив от символи)}
В \cpp низовете могат да се представят и като масиви от символи. Това е по-старият начин за работа с текст в \cpp (произлизащ от низовете в \code{C}).

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
char greeting[] = "Greetings!";
\end{lstlisting}\end{mdframed}

Този код дефинира масив от символи \code{greeting}, който съдържа низа \\\code{"Greetings"}. Важно е да се отбележи, че масивът \code{greeting} трябва да е с достатъчно голям размер, за да събере всички символи от низа, плюс един допълнителен символ \code{'\bs{0}'} (null terminator), който маркира края на низа.

За повече информация за масиви, виж (\ref{sec:array}).

\subsubsection{Низ (\code{string})}
Използва се за съхраняване на поредица от символи, т.е. текст. Представлява обект от класа \code{std::string}, дефиниран в заглавния файл \code{<string>}.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
std::string greeting = "Greetings!";
\end{lstlisting}\end{mdframed}

За повече информация за работа със \code{string} данни, виж (\ref{sec:string}).

\subsubsection{Извличане на числа от \code{string} данни}
За да извлечем число от \code{string}, можем да използваме функциите \code{stoi()}, \code{stol()}, \code{stoll()}, \code{stof()}, \code{stod()}, \code{stold()}, които се намират в заглавния файл \code{<string>}.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <string>

int main() {
    std::string numberString = "12345";
    int numberInt = std::stoi(numberString);
    std::cout << "The number is: " << numberInt << std::endl;

    std::string realNumberString = "3.14159";
    double realNumberDouble = std::stod(realNumberString);
    std::cout << "The real number is: "
        << realNumberDouble << std::endl;

    return 0;
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language={}]
The number is: 12345
The real number is: 3.14159
\end{lstlisting}\end{mdframed}

\textbf{Важно}: Функциите \code{stoi()}, \code{stol()}, \code{stoll()}, \code{stof()}, \code{stod()}, \code{stold()} хвърлят \code{Exception} (виж \ref{sec:exceptions}) от тип \code{std::invalid\_argument}, ако низът не е валидно число.

\section{Логически данни}
В \cpp имаме логически тип данни (\code{bool}), който може да приема само две стойности:

\begin{itemize}
    \item[] \code{true}: Истина
    \item[] \code{false}: Неистина
\end{itemize}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
bool isSunny = true;
bool isRainy = false;
\end{lstlisting}\end{mdframed}

Логическите данни се използват за представяне на условия, които могат да бъдат истинни или неистинни.
В \cpp \code{true} се представя като \code{1} (или всичко различно от \code{0}), а \code{false} се представя като \code{0}.
Логическите операции, като например \code{\&\&} (И), \code{||} (ИЛИ), \code{!} (НЕ), се използват за комбиниране на логически условия.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
bool isSunny = true;
bool isWarm = true;

bool isPerfectDay = isSunny && isWarm; // true

bool isNotPerfectDay = !isPerfectDay; // false
\end{lstlisting}\end{mdframed}

\subsubsection{Използване на логически данни}
Логическите данни се използват широко в \cpp за:
\begin{itemize}
    \item Условни оператори (\code{if}, \code{else if}, \code{else}): За да се изпълнява код само ако дадено условие е истинно.
    \item Цикли (\code{for}, \code{while}, \code{do while}): За да се изпълнява код, докато дадено условие е истинно.
    \item Функции: За да се връщат логически стойности.
\end{itemize}

За условните оператори и циклите ще научим в следващата глава.

\chapter{Конструкции за поточен контрол}
В \cpp протичането на програмата може да се контролира чрез различни конструкции, които определят дали дадени части от кода ще бъдат изпълнени или не.
Тези конструкции са съответно за разклонение в потока, за цикли, за прекъсване и за управление на изключения.

\section{Конструкции за разклонение}
Конструкциите за разклонение ни позволяват да изпълняваме различни части от код в зависимост от резултата от дадено условие. В \cpp имаме 3 основни конструкции за разклонение и 2 алтернативни варианта (частни случаи):
\subsubsection{I. \code{if} оператор}

Използва се за изпълнение на код, само ако дадено условие е истинно.
\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
if (condition) {
    // Код, който се изпълнява, ако условието е истинно
}
// или
if (condition) /* Код за изпълнение */;
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age = 25;

if (age >= 18) {
    std::cout << "You're old enough." << std::endl;
}
\end{lstlisting}\end{mdframed}
\subsubsection{II. \code{if-else} оператор}
Използва се за изпълнение на един от два кода, в зависимост от резултата от дадено условие.

\begin{itemize}\item[Синтаксис:]\end{itemize}\vspace{-6pt}
\begin{mdframed}\begin{lstlisting}
if (condition) {
    // Код, който се изпълнява, ако условието е истинно
} else {
    // Код, който се изпълнява, ако условието е неистинно
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Пример:]\end{itemize}\vspace{-6pt}
\begin{mdframed}\begin{lstlisting}
int age = 15;

if (age >= 18) {
    std::cout << "You're old enough." << std::endl;
} else {
    std::cout << "You're not old enough." << std::endl;
}
\end{lstlisting}\end{mdframed}

\subsubsection{Тернарен оператор (\code{?:})}
Представлява по-кратка форма за писане на \code{if-else} конструкция, когато трябва да запишем стойност на променлива, в зависимост от някакво условие.

\begin{itemize}\item[Синтаксис:]\end{itemize}\vspace{-6pt}
\begin{mdframed}\begin{lstlisting}
<type> <var_name> = <conditon> ? <val_if_true> : <val_if_false>;
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int age = 25;

// `if-else` в случая е по-обемен
if (age >= 18) {
    std::cout << "Adult" << std::endl;
} else {
    std::cout << "Minor" << std::endl;
}

// С тернарен оператор кода става сравнително по-компактен
std::cout << ((age >= 18) ? "Adult" : "Minor") << std::endl;
\end{lstlisting}\end{mdframed}

\subsubsection{III. \code{else-if} оператор}
Използва се за изпълнение на един от няколко кода, в зависимост от резултата от няколко условия.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
if (condition_1) {
    // Код, който се изпълнява, ако condition\_1 е истинно
} else if (condition_2) {
    // Код, който се изпълнява, ако condition\_2 е истинно
} else {
    // Код, който се изпълнява, ако никое от условията не е истинно
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Пример:]\end{itemize}\vspace{-6pt}
\begin{mdframed}\begin{lstlisting}
int grade = 85;

if (grade >= 90) {
    std::cout << "A" << std::endl;
} else if (grade >= 80) {
    std::cout << "B" << std::endl;
} else if (grade >= 70) {
    std::cout << "C" << std::endl;
} else {
    std::cout << "F" << std::endl;
}
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Резултат:]\end{itemize}\vspace{-18pt}
\begin{mdframed}\begin{lstlisting}[language={}]
B
\end{lstlisting}\end{mdframed}

\subsubsection{\code{switch} оператор}\label{sec:switch}
Използва се за проверка на стойността на дадена променлива и изпълнение на код, съответстващ на тази стойност.

\begin{itemize}\item[Синтаксис:]\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}
switch (variable) {
    case value_1:
        // Код, който се изпълнява, ако изразът е равен на value\_1
        break;
    case value_2:
        // Код, който се изпълнява, ако изразът е равен на value\_2
        break;
    default:
        // Код, който се изпълнява, ако изразът
        // не е равен на никоя от стойностите
}
\end{lstlisting}\end{mdframed}\vspace{-16pt}

\begin{itemize}\item[Пример:]\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}
int day = 3;

switch (day) {
    case 1:
        std::cout << "Monday" << std::endl;
        break;
    case 2:
        std::cout << "Tuesday" << std::endl;
        break;
    case 3:
        std::cout << "Wednesday" << std::endl;
        break;
    default:
        std::cout << "Invalid day" << std::endl;
}
\end{lstlisting}\end{mdframed}\vspace{-16pt}

\begin{itemize}\item[Резултат:]\end{itemize}\vspace{-18pt}
\begin{mdframed}\begin{lstlisting}[language={}]
Wednesday
\end{lstlisting}\end{mdframed}

\section{Конструкции за цикъл}
Конструкциите за цикли ни позволяват да изпълняваме даден код многократно, докато дадено условие е истинно. В \cpp имаме 3 основни конструкции за цикли и 1 алтернативен вариант (частен случай):

\subsubsection{I. \code{while} цикъл}
Използва се за изпълнение на код докато дадено условие е истинно.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
while (condition) {
    // Код, който се изпълнява многократно
}
\end{lstlisting}\end{mdframed}

\textbf{Условие}: Проверява се преди всяко повторение на цикъла. Ако условието е истинно, цикълът се изпълнява.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int i = 0;

while (i < 5) {
    std::cout << i << std::endl;
    i++;
}
\end{lstlisting}\end{mdframed}

\code{i++}: Увеличава стойността на \code{i} с \code{1} след всяко повторение на цикъла.

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language={}]
0
1
2
3
4
\end{lstlisting}\end{mdframed}

\textbf{Важно}: Циклите винаги трябва да имат стъпка, в която да се подновява условието, за да се гарантира, че няма да изпадне в безкраен цикъл или изобщо да не се осъществи.

\subsubsection{II. \code{do-while} цикъл}
Използва се за изпълнение на код поне веднъж и след това докато дадено условие е истинно.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
do {
    // Код, който се изпълнява многократно
} while (condition);
\end{lstlisting}\end{mdframed}

\textbf{Условие}: Проверява се след всяко повторение на цикъла. Ако условието е истинно, цикълът се изпълнява отново.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int i = 0;

do {
    std::cout << i << std::endl;
    i++;
} while (i < 5);
\end{lstlisting}\end{mdframed}

\subsubsection{III. \code{for} цикъл}
Използва се за изпълнение на код за определен брой пъти.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
for (initialization; condition; updation) {
    // Код, който се изпълнява многократно
}
\end{lstlisting}\end{mdframed}

\textbf{Инициализация}: Изпълнява се веднъж в началото на цикъла. Обикновено се използва за дефиниране на променлива, която ще се използва за броене на повторенията.

\textbf{Условие}: Проверява се преди всяко повторение на цикъла. Ако условието е истинно, цикълът се изпълнява.

\textbf{Стъпка}: Изпълнява се след всяко повторение на цикъла. Обикновено се използва за промяна на стойността на променливата, използвана за броене.
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
for (int i = 0; i < 5; i++) {
    std::cout << i << std::endl;
}
\end{lstlisting}\end{mdframed}

\subsubsection{\code{for-each} цикъл}
Тази конструкция е частен случай на \code{for} цикъла. Използва се за итериране през елементите на контейнер (например масив, вектор, списък).

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
for (<type> <element> : <container>) {
    // Код, който се изпълнява за всеки елемент
}
\end{lstlisting}\end{mdframed}

\textbf{Тип елемент}: Определя типа на елементите в контейнера.

\textbf{Контейнер}: Определя контейнера от елементи, през който ще се итерира.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int numbers[] = {0, 1, 2, 3, 4}; // Масив от числа

for (int number : numbers) {
    std::cout << number << std::endl;
}
\end{lstlisting}\end{mdframed}

Всяко повторение на цикъла, променливата \code{number} ще приема стойността на следващия елемент в масива \code{numbers}.

\section{Конструкции за прекъсване}
Конструкциите за прекъсване ни позволяват да прекъснем нормалното изпълнение на цикъл или функция. В \cpp имаме четири основни конструкции за прекъсване:

\subsubsection{break}
Използва се за прекъсване на цикъл и излизане от него. Също се ползва и при \code{switch-case} конструкцията (Виж (\ref{sec:switch})).

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break; // Прекъсва цикъла, когато i е 5
    }
    std::cout << i << std::endl;
}
\end{lstlisting}\end{mdframed}

Когато \code{i} е равно на \code{5}, \code{break} прекъсва цикъла и изпълнението продължава от кода след цикъл.

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language={}]
0
1
2
3
4
\end{lstlisting}\end{mdframed}

\subsubsection{continue}
Използва се за прескачане на текущото повторение на цикъл и преминаване към следващото.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) {
        continue; // Прескача четните числа
    }
    std::cout << i << std::endl;
}
\end{lstlisting}\end{mdframed}

Когато \code{i} е четно число, \code{continue} прескача останалата част от кода в цикъла и преминава към следващото повторение.
\pagebreak
\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language={}]
1
3
5
7
9
\end{lstlisting}\end{mdframed}

\subsubsection{return}
Използва се за прекъсване на функция и връщане на стойност. Ако функцията е от тип \code{void}, \code{return} просто прекъсва функцията.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int sum(int a, int b) {
    if (a < 0 || b < 0) {
        return -1; // Връща -1, ако някое от числата е отрицателно
    }
    return a + b;
}
\end{lstlisting}\end{mdframed}

Когато \code{a} или \code{b} е отрицателно, \code{return} прекъсва функцията \code{sum} и връща \code{-1}.

\subsubsection{goto}
Примитивна ключова дума. Използва се за неусловен преход към друга част от кода. Може да доведе до нечетлив код или да пречупи интегритета на кода. Да се използва само при изрична необходимост.

\begin{itemize}\item[Синтаксис:]\end{itemize}\vspace{-4pt}
\begin{mdframed}\begin{lstlisting}
<label_a>:
...
goto <label_a>;

// или

goto <label_b>;
...
<label_b>:
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int main() {
    for (int i = 0; i < 10; i++) {
        if (i == 5) {
            goto end; // Прескача останалата част от цикъла
        }
        std::cout << i << std::endl;
    }

    std::cout << "The code will never go through this message"
        << std::endl;

end:
    std::cout << "End of loop" << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}

Когато \code{i} е равно на \code{5}, \code{goto} прескача останалата част от кода и преминава към кода след етикета \code{end}.

\section{Изключения (Exceptions) и работа с тях}\label{sec:exceptions}
Изключенията са непредвидени събития, които възникват по време на изпълнението на програмата и могат да нарушат нормалния й ход. В \cpp можем да улавяме тези изключения и да обработваме грешките, за да предотвратим сривове на програмата.

\subsubsection{Как се хвърлят изключения?}
Използваме ключовата дума \code{throw} за хвърляне на изключение.
Изключението може да бъде всякакъв тип данни, но най-често се използват класове, които описват типа на грешката.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
throw <exception_type>(<exception_message>);
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <stdexcept> // Включва библиотеката за основните изключения

int main() {
    int a, b;
    std::cout << "Insert two numbers: ";
    std::cin >> a >> b;

    if (b == 0) {
        // Хвърляне на изключение
        throw std::runtime_error("Division by 0!");
    }

    int result = a / b;
    std::cout << "The result is: " << result << std::endl;

    return 0;
}
\end{lstlisting}\end{mdframed}

В този пример, ако потребителят въведе \code{0} за \code{b}, се хвърля изключение от тип \code{std::runtime\_error}.

\subsubsection{Как се улавят изключения?}
Използваме контролната конструкция \code{try-catch}, с основната цел да улавя изключения и да ги обработва без да прекъсва протичането на програмата.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
try {         
    // Код, който може да хвърли изключение
} catch (<exception_type> <exception_name>)  {   
    // Улавя изключението <exception\_name>\ за обработка
}
\end{lstlisting}\end{mdframed}

\begin{itemize}
    \item \code{try} блокът обгръща кода, който може да хвърли изключение.
    \item \code{catch} блокът улавя изключението, ако се хвърли такова.
\end{itemize}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#include <iostream>
#include <string>

int main() {
    std::string str = "Definitely not a number";
    int num;

    try {
        num = stoi(str);
    } catch (std::invalid_argument e) {
        std::cerr << "\"" << str << "\" is NaN!" << std::endl;
    }

    return 0;
}
\end{lstlisting}\end{mdframed}

В примера нарочно се подава като аргумент на функцията \code{std::stoi} низ, който не може да се конвертира в цяло число,
за да се улови изключението за невалиден параметър, да се обработи изключението и да се изведе формално като грешка, без да се прекъсва протичането на програмата.

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
>! "Definitely not a number" is NaN!
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[\textbf{Best}] \textbf{practices}:\end{itemize}
\begin{itemize}
    \item Да не се вкарва целият код в \code{try-catch} конструкция, а само частта, в която може да се изхвърли изключение.
    \item Да не се ползва \code{try-catch} конструкцията като основен начин за обработване на грешки. Конструкцията е предназначена за изключения.
    \item Да се ползва само при необходимост.
\end{itemize}

\chapter{Съставни типове данни}
Съставните типове данни са производни от примитивните типове данни или изобщо нови конструкции, които ни позволяват да групираме данни от различни типове под едно име, създавайки структурирани обекти от данни. 

\section{Масиви}\label{sec:array}
Масивите са структурирани данни, които ни позволяват да съхраняваме множество елементи от един и същ тип под едно име. В \cpp имаме два вида масиви: статични и динамични.

\subsection{Статични масиви}
Статичните масиви се декларират с фиксиран размер по време на компилация.
Съществуват през целия живот на програмата и са статично разпределени в стека.
Те са по-прости за използване, но са ограничени по размер, защото не можем да променяме размера на статичния масив след декларацията му.

\begin{itemize}\item[Дефиниция:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Инициализация с основни стойности (обикновено 0-ли за числени данни)
<type> <name>[<length>];
<type> <name>[<length>] = {};

// Инициализация чрез масивен литерал
<type> <name>[<length>] = {<el_1> , ... , <el_n>}; 
<type> <name>[] = {<el_1> , ... , <el_n>};
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}
int numbers[5]; // Масив от 5 цели числа
\end{lstlisting}\end{mdframed}

Декларацията \code{int numbers[5]} създава масив \code{numbers}, който може да съхранява 5 цели числа.

\textbf{Важно}: Индексите на елементите започват от \code{0} и стигат до (\code{n - 1})\\(В случая до \code{4}).

\begin{itemize}\item[Пример] за промяна и достъп до елемент:\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting} 
numbers[0] = 10; // Присвоява стойност 10 на първия елемент
// Извежда стойността на първия елемент
std::cout << numbers[0] << std::endl;
// Извежда стойността на третия елемент
std::cout << numbers[2] << std::endl; 
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Резултат:]\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}
10
0
\end{lstlisting}\end{mdframed}

\subsection{Динамични масиви}
Динамичните масиви се декларират с размер, който може да се променя по време на изпълнение.
Te са по-гъвкави, но изискват по-внимателно управление на паметта, защото са динамично разпределени в хийпа (Виж (\ref{sec:allocation}))

Декларацията на динамичните масиви се осъществява чрез указатели\\(Виж (\ref{sec:pointers})), сочещи към първия елемент от разпределена в хийпа памет, които трябва да се освободят след приключване на работата с масива.

\begin{itemize}\item[Дефиниция:]\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}
// Без инициализация
<type> *<name>;
<type> *<name> = nullptr;

// Инициализация
<type> *<name> = new <type>[<length>];
...
delete[] <name>; // Освобождаване на разпределената памет!
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int *numbers = new int[5]; // Динамичен масив от 5 цели числа
...
delete[] numbers;
\end{lstlisting}\end{mdframed}

Декларацията \code{int *numbers = new int[5]} създава динамичен масив\\\code{numbers}, който може да съхранява 5 цели числа.

\code{new int[5]} е оператор, който разпределя памет за 5 цели числа на хийпа.

\code{numbers} е указател към първия елемент на масива.

\code{delete[] numbers} освобождава разпределената за масива памет.

\begin{itemize}\item[Пример] за промяна на и достъп до елемент:\end{itemize}
\begin{mdframed}\begin{lstlisting} 
numbers[0] = 10; // Присвоява стойност 10 на първия елемент
// Извежда стойността на първия елемент
std::cout << numbers[0] << std::endl;
// Извежда стойността на третия елемент
std::cout << numbers[2] << std::endl;

// или

*numbers = 10; // Присвоява стойност 10 на първия елемент
// Извежда стойността на първия елемент
std::cout << *numbers << std::endl;

numbers += 2; // Измества адреса на указателя, за да сочи към третия елемент
// Извежда стойността на третия елемент
std::cout << *numbers << std::endl;

delete[] numbers;
\end{lstlisting}\end{mdframed}

\textbf{Важно}: Необходимо е да се освободи паметта, заделена за динамичния масив, след като вече не е необходима, използвайки \code{delete[] numbers}\\(Виж защо в (\ref{sec:allocation})).

\subsection{Дължина на масив}
Дължината на масив се извежда от следната формула:

\begin{mdframed}\begin{lstlisting}
<type> array[n];
\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[firstnumber=2]
std::size_t length = sizeof(array) / sizeof(array[0]);
// или
std::size_t length = sizeof(array) / sizeof(<type>);
\end{lstlisting}\end{mdframed}

Защо не просто \code{sizeof(array)}? Функцията \code{sizeof(<obj>)} Връща бройката байтове, които \code{<obj>} заема, а не бройката елементи (ако изобщо има такива).

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int arr[10];

// 40 байта данни на масив от цели числа
std::cout << "Array bytes: " << sizeof(arr) << endl;

// 4 байта данни от тип цяло число
std::cout << "int bytes: " << sizeof(arr[0]) << endl;

// 40 байта / 4 байта = 10 цели числа
std::size_t length = sizeof(arr) / sizeof(arr[0]);
std::cout << "Array length: " << length << endl;
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language={}]
Array bytes: 40
int bytes: 4
Array length: 10
\end{lstlisting}\end{mdframed}

\section{Структури}
Структурите (\code{struct}) са съставни типове данни, които ни позволяват да групираме данни от различни типове под едно име, създавайки структурирани данни.
Данните в структурите се наричат членове. Структурите са прости за използване и са подходящи за групиране на данни, които не изискват скриване на данни или контрол на достъпа.
\pagebreak
\begin{itemize}\item[Дефиниция:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Именувана структура, дефинира се извън функциите
struct <Struct_Type> {
    <type_1> <var_1>;
    <type_2> <var_2> = <default_value>;
    <type_3> <var_3> , ... , <var_n>; // Няколко еднотипни данни
    ...
};

// Инстанциализация
struct <Struct_Type> <struct_name>;

// Инициализация
<struct_name>.<var_1> = <value_1>;
<struct_name>.<var_2> = <value_2>;
...

// Инстанциализация + Инициализация
struct <Struct_Type> <struct_name> = { <value_1> , ... , <value_n> };

// struct променлива, дефинира се във функция или клас
struct {
    ... // Стандартно дефиниране на данните
} <struct_name>;
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
struct Person {
    std::string name; // Име (текст)
    int age; // Възраст (цяло число)
    double height; // Ръст (число с плаваща запетая)
};
\end{lstlisting}\end{mdframed}

Структурата \code{Person} дефинира нов тип данни, който съдържа три члена: \code{name}, \code{age} и \code{height}.

Членовете на структурата могат да бъдат от различни типове.
\pagebreak
\begin{itemize}\item[Пример] за работа с обект от тип \code{Person}:\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}
Person p1; // Създава обект от тип `Person`

p1.name = "Ivan"; // Присвоява името "Ivan" на члена `name`
p1.age = 25; // Присвоява възрастта 25 на члена `age`
p1.height = 1.80; // Присвоява ръста 1.80 на члена `height`

// или

Person p1 = {"Ivan", 25, 1.80};

std::cout << "The name is: " << p1.name << std::endl;
std::cout << "The age is: " << p1.age << std::endl;
std::cout << "The height is: " << p1.height << std::endl;
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Резултат:]\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}[language={}]
The name is: Ivan
The age is: 25
The height is: 1.8
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Пример] за използване на \code{struct}:\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting} 
#include <iostream>
#include <string>

using namespace std;

struct Student {
    string name;
    int age;
    int grades[5];
};

int main() {
    Student s1;

    s1.name = "Maria";
    s1.age = 18;
    s1.grades[0] = 5;
    s1.grades[1] = 6;
    s1.grades[2] = 4;
    s1.grades[3] = 5;
    s1.grades[4] = 6;
    
\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[firstnumber=last]

    cout << "Name: " << s1.name << endl;
    cout << "Age: " << s1.age << endl;
    cout << "Grades: ";
    for (int i = 0; i < 5; i++) {
        cout << s1.grades[i] << " ";
    }
    cout << endl;

    return 0;
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Резултат:]\end{itemize}\vspace{-10pt}
\begin{mdframed}\begin{lstlisting}[language={}]
Name: Maria
Age: 18
Grades: 5 6 4 5 6 
\end{lstlisting}\end{mdframed}

\section{Обединения}
Обединенията (\code{union}) са съставни типове данни, които ни позволяват да съхраняваме различни типове данни в една и съща памет.
В даден момент може да се съхранява само една от стойностите на членовете.
Достъпът до различните членове се осъществява чрез името на обединението, последвано от името на члена.

\begin{itemize}\item[Дефиниция:]\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}
union <Union_Name> {
    <type_1> <var_1>;
    <type_2> <var_2>;
    ...
};
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Пример:]\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}
union Data {
    int i;
    float f;
    char c;
};
\end{lstlisting}\end{mdframed}

\code{union Data} - Дефинира нов тип данни, наречен Data, който е обединение.

\code{int i}, \code{float f}, \code{char c} - Членовете на обединението, които могат да съхраняват цели числа, числа с плаваща запетая и символи.

\begin{itemize}\item[Пример] за използване на \code{union}:\end{itemize}
\begin{mdframed}\begin{lstlisting}
int main() {
    Data d;

    d.i = 10; // Съхранява цяло число
    std::cout << "d.i = " << d.i << std::endl;

    d.f = 3.14; // Съхранява число с плаваща запетая
    std::cout << "d.f = " << d.f << std::endl;

    d.c = 'A'; // Съхранява символ
    std::cout << "d.c = " << d.c << std::endl;

    return 0;
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language={}]
d.i = 10
d.f = 3.14
d.c = A
\end{lstlisting}\end{mdframed}

\textbf{Важно}: Обединенията са небезопасни, тъй като не е възможно да се проследи кой член е активен в даден момент.
Не е препоръчително да се използват обединения, освен ако не е абсолютно необходимо.
Алтернативи на обединенията са структурите и класовете, които предлагат по-безопасни начини за групиране на данни.

\section{Изброяване}
Изброяванията (\code{enum}) ни позволяват да дефинираме собствени типове данни, които представляват набор от константи. Тези константи са имена, които представляват числови стойности.
Изброяванията ни позволяват да ограничим възможните стойности на променливите.
Те улесняват читаемостта на кода, тъй като имена се използват вместо числа.
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
enum Color { RED, GREEN, BLUE };
\end{lstlisting}\end{mdframed}

\code{enum Color} - Дефинира нов тип данни, наречен Color, който е изброяване.

\code{RED}, \code{GREEN}, \code{BLUE} - Имената на константите, които са част от изброяването.

По подразбиране константите в изброяването получават числови стойности, започвайки от 0.

\begin{itemize}\item[Пример] за използване на \code{enum}:\end{itemize}
\begin{mdframed}\begin{lstlisting}
int main() {
  Color c = GREEN; // Задава стойността на `c` на `GREEN`
  std::cout << "c = " << c << std::endl; // Извежда: c = 1

  return 0;
}
\end{lstlisting}\end{mdframed}

Изброяванията могат да се инициализират ръчно с числови стойности.

\begin{itemize}\item[Пример] за ръчно инициализиране:\end{itemize}
\begin{mdframed}\begin{lstlisting}
enum Weekday { MON = 1, TUE, WED, THU, FRI, SAT, SUN };
\end{lstlisting}\end{mdframed}

\code{MON} е инициализиран с \code{1}.

\code{TUE}, \code{WED}, \code{THU}, \code{FRI}, \code{SAT}, \code{SUN} са инициализирани с \code{2}, \code{3}, \code{4}, \code{5}, \code{6}, \code{7} съответно.

Изброяванията са полезни за:
\begin{itemize}
    \item[--] Дефиниране на константи, които са лесни за четене и разбиране.
    \item[--] Ограничаване на възможните стойности на променливите.
    \item[--] Управление на типове данни в приложения, където е необходимо да се използват ограничен брой стойности.
\end{itemize}

\section{Класове}
Класовете са основен градивен елемент в обектно-ориентираното програмиране (ООП) в \cpp. Те ни позволяват да дефинираме собствени типове данни, които инкапсулират данни и функции, свързани с тях. По този начин може да се описват обекти от истинския свят, редом с техните аспекти и функционалности.

Основни характеристики на класовете:
\begin{itemize}
    \item Атрибути: Данните, които се съхраняват в обекти от класа. Те се дефинират като член-данни на класа.
    \item Методи: Функциите, които оперират с данните на класа, или с други класове и функции. Те се дефинират като член-функции на класа.
    \item Инкапсулация: Скриване на данните и методите на класа от външния свят.
    \item Абстракция: Представяне на класа само с неговите публични интерфейси, без да се показват подробности за имплементацията.
    \item Наследственост: Възможност за създаване на нови подкласове, които наследяват свойствата и методите на съществуващи класове.
    \item Полиморфизъм: Възможност за различно поведение на методите, в зависимост от типа на обекта, към който се прилагат.
\end{itemize}

\begin{itemize}\item[Дефиниция:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
class <Class_Name> {
<access_specifier>: // private, protected или public
    ... // Променливи

    // Конструктор
    <Class_Name>(list_of_parameters) {
        ... // Дефиниция на обекта
    }

    ... // Функции

    // Деструктор
    ~<Class_Name>() {
        ... // Деконструкция на обекта
    }
}
\end{lstlisting}\end{mdframed}

\begin{itemize}
    \item \code{class} - Ключова дума за създаване на клас.
    \item \code{<access\_specifier>} - Ключови думи, определящи достъпа до конкретни променливи, функции, конструктори или деструктори.\\\code{private:} скрива данните от други класове. \code{protected:} скрива данните от всички класове, които не унаследяват този клас. \code{public:} прави данните видими от всички класове.
    \item Конструктор - Специален метод, който се извиква при създаването на обект от типа на класа. Ако не е дефиниран от потребителя, компилатора го дефинира автоматично по стандарт.
    \item Деструктор - Специален метод, който се извиква при унищожаването на дадена инстанция на класа. Ако не е дефиниран от потребителя, компилатора го дефинира автоматично по стандарт.
\end{itemize}

\begin{itemize}\item[Пример] за дефиниране на клас:\end{itemize}
\begin{mdframed}\begin{lstlisting}
class Rectangle {
private:
    double width;
    double height;
\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[firstnumber=last]

public:
    // Конструктор
    Rectangle(double w, double h) : width(w), height(h) {}

    // Методи
    double getArea() const {
        return width * height;
    }

    double getPerimeter() const {
        return 2 * (width + height);
    }
};
\end{lstlisting}\end{mdframed}

\begin{itemize}
    \item[--] \code{class Rectangle} - Дефинира нов тип данни, наречен \code{Rectangle}.
    \item[--] \code{private:} - Секция, която съдържа частните член-данни на класа. Те са недостъпни отвън.
    \item[--] \code{width} и \code{height} - Частните член-данни, които съхраняват ширината и височината на правоъгълника.
    \item[--] \code{public:} - Секция, която съдържа публичните член-функции на класа. Те са достъпни отвън.
    \item[--] \code{Rectangle(double w, double h)} - Конструктор, който се извиква при създаване на обект от тип \code{Rectangle}.
    \item[--] \code{getArea()} и \code{getPerimeter()} - Публични член-функции, които връщат\\площта и периметъра на правоъгълника.
\end{itemize}

\begin{itemize}\item[Пример] за използване на клас:\end{itemize}
\begin{mdframed}\begin{lstlisting}
int main() {
    Rectangle rect1(5.0, 3.0); // Създава обект от тип `Rectangle`

    std::cout << "The area is: " << rect1.getArea() << std::endl;
    std::cout << "The perimeter is: " << rect1.getPerimeter() << std::endl;
    return 0;
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Резултат:]\end{itemize}
\begin{mdframed}\begin{lstlisting}[language={}]
The area is: 15
The perimeter is: 16
\end{lstlisting}\end{mdframed}

\section{Колекции}
Колекциите в \cpp са структури от данни, които ни позволяват да съхраняваме множество елементи от един и същ тип. Тези структури ни дават гъвкавост при обработката на данни, като ни позволяват да добавяме, премахваме, сортираме и търсим елементи по ефективен начин.

\subsection{Вектор}
Векторите в \cpp са динамични масиви, които съхраняват елементи от един и същ тип. За разлика от статичните масиви, векторите могат да разширяват размера си динамично, което ги прави гъвкави за работа с променлив брой елементи.

\begin{itemize}\item[Дефиниция:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#include <vector>

std::vector<int> numbers; // Дефинира вектор от цели числа
std::vector<std::string> names; // Дефинира вектор от низове
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Добавяне] на елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
numbers.push_back(10); // Добавя 10 към края на вектора
numbers.push_back(20); // Добавя 20 към края на вектора
names.push_back("Ivan"); // Добавя "Ivan"\ към края на вектора
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Достъп] до елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
int firstNumber = numbers[0]; // Достъп до първия елемент
std::string secondName = names[1]; // Достъп до втория елемент
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Размер] на вектора:\end{itemize}
\begin{mdframed}\begin{lstlisting}
int size = numbers.size(); // Връща броя на елементите във вектора
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Итериране] през вектора:\end{itemize}
\begin{mdframed}\begin{lstlisting}
for (int i = 0; i < numbers.size(); i++) {
    std::cout << numbers[i] << " ";
}
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Изтриване] на елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
numbers.erase(numbers.begin() + 1); // Изтрива втория елемент
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Други] полезни методи:\end{itemize}
\begin{itemize}
    \item \code{clear()}: Изтрива всички елементи от вектора.
    \item \code{empty()}: Връща \code{true}, ако векторът е празен, и \code{false} в противен случай.
    \item \code{front()}: Връща референция към първия елемент.
    \item \code{back()}: Връща референция към последния елемент.
    \item \code{insert()}: Вмъква елемент на определена позиция.
\end{itemize}

\begin{itemize}\item[Предимства] на векторите:\end{itemize}
\begin{itemize}
    \item[--] Динамично разширяване: Могат да съхраняват променлив брой елементи.
    \item[--] Лесна работа: Предлагат удобни методи за добавяне, премахване, достъп и итериране.
    \item[--] Ефективност: Осигуряват бърз достъп до елементите.
\end{itemize}

\subsection{Списък}
Списъците в \cpp са динамични структури от данни, които съхраняват елементи в свързана верига. Всеки елемент в списъка съдържа данни и посока към следващия елемент.

\begin{itemize}\item[Дефиниция:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#include <list>

std::list<int> numbers; // Дефинира списък от цели числа
std::list<std::string> names; // Дефинира списък от низове
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Добавяне] на елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
numbers.push_back(10); // Добавя 10 в края на списъка
numbers.push_front(5); // Добавя 5 в началото на списъка
names.push_back("Ivan"); // Добавя "Ivan"\ в края на списъка
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Достъп] до елементи: Списъците не поддържат индексиране. За достъп до елементи се използват итератори.\end{itemize}
\begin{mdframed}\begin{lstlisting}
std::list<int>::iterator it = numbers.begin(); // Итератор към началото
int firstNumber = *it; // Достъп до първия елемент
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Размер] на списъка:\end{itemize}
\begin{mdframed}\begin{lstlisting}
int size = numbers.size(); // Връща броя на елементите в списъка
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Итериране] през списък:\end{itemize}
\begin{mdframed}\begin{lstlisting}
for (
    std::list<int>::iterator it = numbers.begin();
    it != numbers.end();
    ++it
) {
    std::cout << *it << " ";
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Изтриване] на елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
numbers.erase(numbers.begin()); // Изтрива първия елемент
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Други] полезни методи:\end{itemize}
\begin{itemize}
    \item \code{clear()}: Изтрива всички елементи от списъка.
    \item \code{empty()}: Връща \code{true}, ако списъкът е празен, и \code{false} в противен случай.
    \item \code{front()}: Връща референция към първия елемент.
    \item \code{back()}: Връща референция към последния елемент.
    \item \code{insert()}: Вмъква елемент на определена позиция.
    \item \code{sort()}: Сортира елементите в списъка.
    \item \code{reverse()}: Обръща реда на елементите в списъка.
\end{itemize}

\begin{itemize}\item[Предимства] на списъците:\end{itemize}
\begin{itemize}
    \item[--] Динамично разширяване: Могат да съхраняват променлив брой елементи.
    \item[--] Ефективност при вмъкване/изтриване: Позволяват бързо вмъкване и изтриване на елементи на всяка позиция.
    \item[--] Гъвкавост: Поддържат различни операции, като сортиране, обръщане и т.н.
\end{itemize}

\subsection{Стек}
Стекът в \cpp е линейна структура от данни, която съхранява елементи по правилото LIFO (Last In, First Out) - последният добавен елемент е първият, който се извлича. Може да се представи като купчина предмети, където можем да добавяме предмети отгоре и да изваждаме само отгоре.

\begin{itemize}\item[Дефиниция:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#include <stack>

std::stack<int> numbers; // Дефинира стек от цели числа
std::stack<std::string> names; // Дефинира стек от низове
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Добавяне] на елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
numbers.push(10); // Добавя 10 в стека
numbers.push(20); // Добавя 20 в стека
names.push("Ivan"); // Добавя "Ivan"\ в стека
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Извличане] на елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Връща последния елемент (без да го изтрива)
int topNumber = numbers.top();
numbers.pop(); // Изтрива последния елемент
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Проверка] за празен стек:\end{itemize}
\begin{mdframed}\begin{lstlisting}
bool isEmpty = numbers.empty(); // Връща true, ако стекът е празен
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Размер] на стека:\end{itemize}
\begin{mdframed}\begin{lstlisting}
int size = numbers.size(); // Връща броя на елементите в стека
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Предимства] на стека:\end{itemize}
\begin{itemize}
    \item[--] Ефективност: Операциите за добавяне (\code{push}) и извличане (\code{pop}) са бързи.
    \item[--] Проста реализация: Лесна за разбиране и имплементиране.
    \item[--] Широко приложение: Използва се в разнообразни алгоритми и структури от данни, например рекурсия, обработка на изрази, обработка на грешки.
\end{itemize}

\subsection{Опашка}
Опашката в \cpp е линейна структура от данни, която съхранява елементи по правилото FIFO (First In, First Out) - първият добавен елемент е първият, който се извлича. Може да се представи като опашка в магазин, където клиентите се обслужват по ред.

\begin{itemize}\item[Дефиниция:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#include <queue>

std::queue<int> numbers; // Дефинира опашка от цели числа
std::queue<std::string> names; // Дефинира опашка от низове
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Добавяне] на елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
numbers.push(10); // Добавя 10 в опашката
numbers.push(20); // Добавя 20 в опашката
names.push("Ivan"); // Добавя "Ivan"\ в опашката
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Извличане] на елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Връща първия елемент (без да го изтрива)
int frontNumber = numbers.front();
numbers.pop(); // Изтрива първия елемент
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Проверка] за празна опашка:\end{itemize}
\begin{mdframed}\begin{lstlisting}
bool isEmpty = numbers.empty(); // Връща true, ако опашката е празна
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Размер] на опашката:\end{itemize}
\begin{mdframed}\begin{lstlisting}
int size = numbers.size(); // Връща броя на елементите в опашката
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Предимства] на опашката:\end{itemize}
\begin{itemize}
    \item[--] Ефективност: Операциите за добавяне (\code{push}) и извличане (\code{pop}) са бързи.
    \item[--] Проста реализация: Лесна за разбиране и имплементиране.
    \item[--] Широко приложение: Използва се в разнообразни алгоритми и структури от данни, например обработка на задачи, симулация на системи, мрежови протоколи.
\end{itemize}

\subsection{Двойнокрайна опашка}
Двойнокрайна опашка (Deque, произлиза от "double-ended queue") в \cpp е линейна структура от данни, която позволява добавяне и извличане на елементи както от началото, така и от края. Може да се представи като опашка, която е отворена и от две страни.
\pagebreak
\begin{itemize}\item[Дефиниция:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#include <deque>

std::deque<int> numbers; // Дефинира двойнокрайна опашка от цели числа
std::deque<std::string> names; // Дефинира двойнокрайна опашка от низове
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Добавяне] на елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
numbers.push_front(10); // Добавя 10 в началото на опашката
numbers.push_back(20); // Добавя 20 в края на опашката
names.push_front("Ivan"); // Добавя "Ivan"\ в началото на опашката
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Извличане] на елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Връща първия елемент (без да го изтрива)
int frontNumber = numbers.front();
numbers.pop_front(); // Изтрива първия елемент

// Връща последния елемент (без да го изтрива)
int backNumber = numbers.back();
numbers.pop_back(); // Изтрива последния елемент
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Проверка] за празна двойнокрайна опашка:\end{itemize}
\begin{mdframed}\begin{lstlisting}
bool isEmpty = numbers.empty(); // Връща true, ако опашката е празна
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Размер] на двойнокрайна опашка:\end{itemize}
\begin{mdframed}\begin{lstlisting}
int size = numbers.size(); // Връща броя на елементите в опашката
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Предимства] на двойнокрайна опашка:\end{itemize}
\begin{itemize}
    \item[--] Гъвкавост: Позволява добавяне и извличане от две страни, което я прави по-гъвкава от обикновена опашка.
    \item[--] Ефективност: Операциите за добавяне и извличане са бързи.
    \item[--] Широко приложение: Използва се в разнообразни алгоритми и структури от данни, например обработка на буфери, реализация на стекове, реализация на опашки.
\end{itemize}

\subsection{Множество}
Множеството (Set) в \cpp е структура от данни, която съхранява елементи в подреден ред, без дубликати. Може да се представи като множество в математиката, където всеки елемент се появява само веднъж.

\begin{itemize}\item[Дефиниция:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#include <set>

std::set<int> numbers; // Дефинира множество от цели числа
std::set<std::string> names; // Дефинира множество от низове
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Добавяне] на елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
numbers.insert(10); // Добавя 10 в множеството (ако не е вече там)
numbers.insert(20); // Добавя 20 в множеството (ако не е вече там)
names.insert("Ivan"); // Добавя "Ivan"\ в множеството (ако не е вече там)
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Проверка] за наличие на елемент:\end{itemize}
\begin{mdframed}\begin{lstlisting}
bool contains = numbers.count(10); // Връща true, ако 10 е в множеството
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Изтриване] на елемент:\end{itemize}
\begin{mdframed}\begin{lstlisting}
numbers.erase(10); // Изтрива 10 от множеството (ако е там)
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Размер] на множеството:\end{itemize}
\begin{mdframed}\begin{lstlisting}
int size = numbers.size(); // Връща броя на елементите в множеството
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Предимства] на множеството:\end{itemize}
\begin{itemize}
    \item[--] Подреждане: Елементите са подредени по ключ, което улеснява търсенето.
    \item[--] Ефективност: Операциите за добавяне, изтриване и търсене са бързи.
    \item[--] Единственост: Не се допускат дубликати, което гарантира уникалност на елементите.
    \item[--] Широко приложение: Използва се в разнообразни алгоритми и структури от данни, например проверка за дубликати, търсене на минимален или максимален елемент, реализация на графове.
\end{itemize}

\subsection{Карта}
Картата (Map) в \cpp е структура от данни, която съхранява двойки от ключ и стойност, като ключът е уникален. Може да се представи като речник, където всеки ключ е свързан с единствена стойност.

\begin{itemize}\item[Дефиниция:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
#include <map>

// Дефинира карта, където ключовете са цели числа, а стойностите са низове
std::map<int, std::string> names;
// Дефинира карта, където ключовете са низове, а стойностите са цели числа
std::map<std::string, int> ages;
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Добавяне] на елементи:\end{itemize}
\begin{mdframed}\begin{lstlisting}
names[10] = "Ivan"; // Добавя двойка (10, "Ivan") в картата
// Добавя двойка (20, "Peter") в картата
names.insert(std::make_pair(20, "Peter"));
ages["Ivan"] = 25; // Добавя двойка ("Ivan"\, 25) в картата
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Достъп] до стойност по ключ:\end{itemize}
\begin{mdframed}\begin{lstlisting}
std::string name = names[10]; // Връща стойността, свързана с ключа 10
int age = ages["Ivan"]; // Връща стойността, свързана с ключа "Ivan"
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Проверка] за наличие на ключ:\end{itemize}
\begin{mdframed}\begin{lstlisting}
bool exists = names.count(10); // Връща true, ако ключът 10 е в картата
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Изтриване] на елемент:\end{itemize}
\begin{mdframed}\begin{lstlisting}
names.erase(10); // Изтрива двойката, свързана с ключа 10
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Размер] на картата:\end{itemize}
\begin{mdframed}\begin{lstlisting}
int size = names.size(); // Връща броя на елементите в картата
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Предимства] на картата:\end{itemize}
\begin{itemize}
    \item[--] Ефективност: Операциите за добавяне, изтриване и търсене са бързи.
    \item[--] Уникалност: Не се допускат дубликати на ключове, което гарантира единственост.
    \item[--] Асоциация: Свързва ключове с стойности, което улеснява достъпа до данни.
    \item[--] Широко приложение: Използва се в разнообразни алгоритми и структури от данни, например реализация на речници, търсене на данни по ключ, обработка на конфигурационни файлове.
\end{itemize}

\section{Ключовата дума \code{typedef}}
\code{typedef} в \cpp е ключова дума, която ви позволява да дефинирате ново име за съществуващ тип данни. Това може да улесни кода ви, като го направи по-четлив и по-лесен за разбиране. Може да се използва също извън функции и класове, т.е. да се дефинират прякори на типове данни извън протичането на програмата.
\code{typedef} не създава нов тип данни, а само дефинира ново име за съществуващ.
Не може да се използва за дефиниране на нови класове или структури.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
typedef <type_name> <new_type_name>;
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Дефинира новото име ULLI за типа unsigned long long int
typedef (unsigned long long int) ULLI;
\end{lstlisting}\end{mdframed}
\pagebreak
Ползи от \code{typedef}:
\begin{itemize}
    \item[--] По-четлив код: Използването на ясни имена за типове може да улесни разбирането на кода.
    \item[--] По-лесно пренаписване: Ако трябва да промените типа на променлива, можете да промените само \code{typedef} дефиницията.
    \item[--] По-кратки имена: Можете да създадете кратки имена за дълги типове данни.
\end{itemize}

\begin{itemize}\item[Пример:] за използване:\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Дефинира по-кратко име за типа итератор през списък от цели числа
typedef (std::list<int>::iterator) IntLstIterator;

IntLstIterator it = nullptr;
\end{lstlisting}\end{mdframed}

\chapter{Манипулиране на паметта}
В \cpp можем да манипулираме паметта директно, използвайки указатели, адреси и адресна аритметика. Това ни дава голяма гъвкавост в управлението на програмното изпълнение и ни позволява да оптимизираме на системно ниво заетостта на паметта, но изисква внимателно боравене, за да се избегнат грешки и проблеми с сигурността.

\section{Указатели}\label{sec:pointers}
Указателите са мощен инструмент в \cpp, който ви позволява да манипулирате паметта директно. Те са променливи, които съхраняват адреса на друга променлива. С помощта на указатели можем да достъпваме и модифицираме стойността на променливата, на която сочат.

\subsubsection{Дефиниране на указател}
За да дефинираме указател, използваме символа \code{*} пред името на променливата. Типът на указателя трябва да съответства на типа на променливата, чийто адрес ще съхранява.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
<type> *<name>; // Конвенционално избран синтаксис
\\ или
<type>* <name>;
\\ или
<type> * <name>;
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Дефинира указател ptr, който може да съхранява
// адрес на променлива от тип int
int *ptr;

// Дефинира указател dptr, който може да съхранява
// адрес на променлива от тип double
double *dptr;
\end{lstlisting}\end{mdframed}

\subsubsection{Задаване на адрес на указател}
За да зададем адрес на указател, използваме оператора \code{\&} пред името на променливата. Това се нарича директно адресиране на променлива.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int num = 10;
ptr = &num; // Задава адреса на num на указателя ptr
\end{lstlisting}\end{mdframed}

\subsubsection{Достъп до стойността на променливата}
За да достъпваме стойността на променливата, на която сочи указателят, използваме оператора \code{*} пред името на указателя.
Това се нарича директно дереференциране на указателя.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Връща стойността, съхранявана на адреса, на който сочи ptr
int value = *ptr;
\end{lstlisting}\end{mdframed}

\subsubsection{Модифициране на стойността на променливата}
За да модифицираме стойността на променливата, на която сочи указателят, използваме оператора \code{*} пред името на указателя, последвано от знак за присвояване.
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
*ptr = 20; // Променя стойността на променливата, на която сочи ptr, на 20
\end{lstlisting}\end{mdframed}

\subsubsection{Нулев указател}
Указателите могат да бъдат нулеви, което означава, че не сочат към никаква променлива. Нулевият указател се представя с константата \code{nullptr}.

\begin{mdframed}\begin{lstlisting}
ptr = nullptr; // Променя ptr да не сочи към никъде
\end{lstlisting}\end{mdframed}

\subsubsection{Използване на указатели}
\begin{itemize}
    \item[--] Предаване на аргументи по адрес: При предаване на аргументи във функция, функцията създава копие на техните стойности и работи съответно с копията, а не с оригиналните аргументи. Указателите ни позволяват да предаваме аргументи на функции по адрес, което ни дава възможност да модифицираме стойността на оригиналната променлива.
    \item[--] Динамично разпределение на паметта: Указателите се използват за динамично разпределение на паметта, което ни позволява да създаваме променливи по време на изпълнение.
    \item[--] Работа с масиви: Указателите са ефективен начин за достъп до елементите на масив.
\end{itemize}

Препоръки за работа с указатели:
\begin{itemize}
    \item[--] Винаги проверявайте стойността на указателя, преди да достъпвате променливата, на която сочи.
    \item[--] Бъдете внимателни при използване на адресна аритметика, тъй като може да доведе до грешки в паметта.
\end{itemize}

\section{Референции}
Референциите в \cpp са специален тип променлива, която не е самостоятелна, а е псевдоним на съществуваща променлива. Те са мощен инструмент, който ни позволява да работим с данни по по-ефективен и удобен начин.

\subsubsection{Дефиниране на референция}
За да дефинираме референция, използваме символа \code{\&} след типа на променливата, следван от името на референцията и знак за присвояване, последван от името на променливата, на която референцията ще е псевдоним.

\begin{itemize}\item[Синтаксис:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
<type> &<ref_name> = <var_name>; // Конвенционално избран синтаксис
// или
<type>& <ref_name> = <var_name>;
// или
<type> & <ref_name> = <var_name>;
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int num = 10;
int &ref = num; // ref е референция към num
\end{lstlisting}\end{mdframed}

В този пример \code{ref} е псевдоним на \code{num}. Всяка операция, извършена над \code{ref}, действа директно върху \code{num}.

\subsubsection{Характеристики на референциите}
\begin{itemize}
    \item[--] Не са самостоятелни: Референциите не съхраняват стойност сами. Те не са променливи в класическия смисъл.
    \item[--] Псевдоним: Референцията е просто друго име за съществуваща променлива.
    \item[--] Не могат да бъдат презададени: След като референцията е дефинирана, тя е свързана с променливата си завинаги. Не може да се презададе да сочи към друга променлива.
    \item[--] Не могат да бъдат нулеви: Референциите винаги трябва да сочат към валидна променлива. Не могат да сочат към невалиден адрес.    
\end{itemize}

\subsubsection{Примери за използване на референции}
Предаване на аргументи по адрес: Референциите ни позволяват да предаваме аргументи на функции по адрес, без да създаваме нови променливи. Това е по-ефективно и по-ясно от използването на указатели.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 10, y = 20;
    swap(x, y);
    cout << "x: " << x << ", y: " << y << endl; // x: 20, y: 10
    return 0;
}
\end{lstlisting}\end{mdframed}

Увеличаване на ефективността: Референциите са по-ефективни от указателите, тъй като не създават нови променливи. Те работят директно с оригиналната променлива, без да копират стойността.

\section{Адресна аритметика}
Адресна аритметика е специална форма на аритметика, която се прилага към указатели. Тя ни позволява да манипулираме адресите, съхранявани в указателите, за да достъпваме различни места в паметта.

\subsection{Основни операции}
\subsubsection{Събиране}
Когато събираме цяло число към указател, адресът, към който сочи, се премества напред с броя байтове, съответстващи на типа на променливата, към която сочи указателят.
\pagebreak
\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr; // ptr сочи към arr[0]
ptr += 2; // ptr сега сочи към arr[2]
\end{lstlisting}\end{mdframed}

\subsubsection{Изваждане}
Когато изваждаме цяло число от указател, адресът, към който сочи, се премества назад с броя байтове, съответстващи на типа на променливата, към която сочи указателят.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr + 3; // ptr сочи към arr[3]
ptr -= 1; // ptr сега сочи към arr[2]
\end{lstlisting}\end{mdframed}

\subsubsection{Разлика}
Можем да извадим два указателя, сочещи към елементи от един и същ масив. Резултатът е разликата в индексите между двамата указателя.

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int arr[5] = {1, 2, 3, 4, 5};
int *ptr1 = arr + 2; // ptr1 сочи към arr[2]
int *ptr2 = arr; // ptr2 сочи към arr[0]
int diff = ptr1 - ptr2; // diff е 2
\end{lstlisting}\end{mdframed}

\subsubsection{Важно забележка}
\begin{itemize}
    \item[--] Адресна аритметика работи само с указатели, сочещи към елементи от един и същ масив.
    \item[--] Преместването на указател извън границите на масива може да доведат до непредвидени резултати и грешки.
\end{itemize}

\subsubsection{Примери за използване на адресната аритметика}
\begin{itemize}
    \item[--] Обработка на масиви: Адресна аритметика е необходима за ефективна обработка на масиви.
    \item[--] Работа с динамично разпределена памет: Адресна аритметика се използва за манипулиране на блокове от памет, разпределени динамично.
    \item[--] Реализация на алгоритми: Адресна аритметика е ключова за реализацията на много алгоритми, като сортиране, търсене и обработка на списъци.
\end{itemize}

\section{Динамично и статично разпределяне на паметта}\label{sec:allocation}
В \cpp, паметта, необходима за съхранение на данни, се разпределя по два основни начина: статично и динамично. Всеки от тези методи има своите предимства и недостатъци, което ги прави подходящи за различни ситуации.

\subsection{Статично разпределяне на паметта}
При статичното разпределяне на паметта, компилаторът определя размера и местоположението на паметта, необходима за променливите, преди програмата да започне да се изпълнява. Разпределя се в стека на паметта и съществува през целия жизнен цикъл на програмата. Тази памет е фиксирана и не може да се променя по време на изпълнение.

\subsubsection{Характеристики:}
\begin{itemize}
    \item[--] Заделяне по време на компилация: Паметта се заделя автоматично от компилатора, когато програмата се компилира.
    \item[--] Фиксиран размер: Размерът на паметта, заделена за променливите, е фиксиран и не може да се променя по време на изпълнение.
    \item[--] Достъпност през целия жизнен цикъл: Променливите, за които е заделена памет статично, са достъпни през целия жизнен цикъл на програмата.
    \item[--] Лесно управление: Управлението на статично заделена памет е по-лесно, тъй като компилаторът се грижи за нея.
    \item[--] По-малко гъвкаво: Статичното разпределяне е по-малко гъвкаво, тъй като размерът на паметта не може да се променя по време на изпълнение.
\end{itemize}

Примери:
\begin{itemize}
    \item[--] Локални променливи: Локалните променливи, дефинирани в функции, се заделят статично.
    \item[--] Глобални променливи: Глобалните променливи, дефинирани извън функции, се заделят статично.
    \item[--] Статични променливи: Статичните променливи, дефинирани с ключовата дума static, се заделят статично.
\end{itemize}

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int num = 10; // Паметта за num се заделя статично
\end{lstlisting}\end{mdframed}

\subsection{Динамично разпределяне на паметта}
При динамичното разпределяне на паметта, програмата заделя памет по време на изпълнение, когато е необходимо. Разпределя се върху хийпа на паметта. Тази памет е гъвкава и може да се разширява или намалява по време на изпълнение.

\subsubsection{Характеристики:}

\begin{itemize}
    \item[--] Заделяне по време на изпълнение: Паметта се заделя динамично от програмата по време на изпълнение, когато е необходимо.
    \item[--] Променлив размер: Размерът на паметта, заделена динамично, може да се променя по време на изпълнение.
    \item[--] Достъпност до освобождаване: Паметта, заделена динамично, е достъпна докато не бъде освободена от програмата.
    \item[--] По-гъвкаво: Динамичното разпределяне е по-гъвкаво, тъй като размерът на паметта може да се променя по време на изпълнение.
    \item[--] По-сложно управление: Управлението на динамично заделена памет е по-сложно, тъй като програмистът трябва да се грижи за освобождаването на паметта, когато вече не е необходима.
\end{itemize}
\pagebreak
Примери:
\begin{itemize}
    \item[--] Динамични масиви: Динамичните масиви, дефинирани с ключовата дума new, се заделят динамично.
    \item[--] Структури и класове: Паметта за структури и класове може да се заделя динамично, когато е необходимо.
\end{itemize}

\begin{itemize}\item[Пример:]\end{itemize}
\begin{mdframed}\begin{lstlisting}
int *ptr = new int; // Паметта за ptr се заделя динамично
...
delete ptr; // Освобождаване на паметта
\end{lstlisting}\end{mdframed}

\subsubsection{Използване на статично и динамично разпределяне}
Статичното разпределяне е подходящо за променливи, чийто размер е известен преди компилация, или за променливи, чийто размер е фиксиран и не се променя по време на изпълнение.

Динамичното разпределяне е подходящо за променливи, чийто размер е неизвестен преди компилация, или за променливи, чийто размер се променя по време на изпълнение.

\subsubsection{Важно е да се отбележи:}
Освобождаване на паметта: Когато се използва динамично разпределяне, е важно да се освободи паметта, когато вече не е необходима. В противен случай, програмата може да изчерпи паметта.

Прекаленото използване на динамично разпределяне: Прекаленото използване на динамично разпределяне може да доведе до проблеми с производителността, тъй като програмата трябва да се справя с операции за заделяне и освобождаване на памет.

\chapter{Алгоритми}
Алгоритмите са основата на програмирането. Те са последователност от стъпки, които описват как да се реши даден проблем. Без алгоритми, програмите биха били хаотични и непредсказуеми.

Значението на алгоритмите в програмирането се крие в следните аспекти:
\begin{itemize}
    \item Ефективност: Алгоритмите определят ефективността на програмата. Ефективни алгоритми използват по-малко ресурси (време, памет) за решаване на проблем.
    \item Яснота: Алгоритмите описват логиката на програмата по ясен и структуриран начин.
    \item Повторна употреба: Алгоритмите могат да се използват повторно в различни програми.
    \item Разбиране: Алгоритмите помагат на програмистите да разберат как работи програмата.
    \item Управление на сложността: Алгоритмите помагат да се управява сложността на програмите, особено при решаване на големи проблеми.
\end{itemize}

\section{Анализа на сложността}
Анализът на сложността на алгоритмите е ключов аспект в програмирането, който ни позволява да оценим ефективността на алгоритмите и да сравним различни алгоритми за решаване на един и същ проблем.
Сложността на алгоритъма се измерва с времевата и паметната сложност.

\pagebreak
За тази цел се използва асимптотичната нотация:
\begin{itemize}
    \item $O(\dots)$ ("Голямо-О"\ Нотация) - обозначава най-лошият случай за протичане на алгоритъма ("Протича не по-бавно отколкото \dots")
    \item $\Theta(\dots)$ ("Тета"\ Нотация) - обозначава средната сложност на алгоритъма ("Протича толкова бързо колкото \dots")
    \item $\Omega(\dots)$ ("Омега"\ Нотация) - обозначава най-добрият случай за протичане на алгоритъма ("Протича не по-бързо отколкото \dots")
\end{itemize}

$O$, $\Omega$ и $\Theta$ са специални оператори, обозначаващи множества от функции от даден порядък на величина:

\begin{equation*}
    f(n)\in
    \begin{cases}
        O(g(n)) \Leftrightarrow\ f \preceq g \Leftrightarrow\ \limsup_{n\to\infty} \left|\frac{f(n)}{g(n)}\right| < \infty\\
        \Theta(g(n)) \Leftrightarrow\ f \asymp g \Leftrightarrow\ \lim_{n\to\infty} \left|\frac{f(n)}{g(n)}\right| \in (0, \infty)\\
        \Omega(g(n)) \Leftrightarrow\ f \succeq g \Leftrightarrow\ \liminf_{n\to\infty} \left|\frac{f(n)}{g(n)}\right| > 0
    \end{cases}
\end{equation*}

Свойства:
\begin{align*}
    f(n) + g(n) &= O(\max(f,g)(n))\\
    f(n) \cdot g(n) &= O((f \cdot g)(n))
\end{align*}

\subsubsection{Времева сложност}
Времевата сложност описва колко време е необходимо на алгоритъма да се изпълни в зависимост от размера на входните данни. Измерва се с броя на операциите, които алгоритъмът извършва.

Означения:
\begin{itemize}
    \item[] $O(1)$: Константна сложност - броят на операциите е независим от размера на входните данни.
    \item[] $O(n)$: Линейна сложност - броят на операциите е пропорционален на размера на входните данни.
    \item[] $O(n^2)$: Квадратна сложност - броят на операциите е пропорционален на квадрата на размера на входните данни.
    \item[] $O(\log n)$: Логаритмична сложност - броят на операциите е пропорционален на логаритъма на размера на входните данни.
\end{itemize}
\pagebreak
Пример:
\begin{itemize}
    \item[] Линейно търсене: Алгоритъмът за линейно търсене има времева сложност $O(n)$, тъй като преглежда всички елементи на масива, за да намери търсеното число.
    \item[] Двоично търсене: Алгоритъмът за двоично търсене има времева сложност $O(\log n)$, тъй като разделя масива на половина при всяка стъпка.
\end{itemize}

Как се изчислява времевата сложност на стъпките:
\begin{itemize}
    \item[] Линеен код: събира се.
    \item[] Вложени цикли: умножават се.\\(Примерно два вложени \code{for} цикъла протичат в $O(n^2)$)
    \item[] Рекурсии: в зависимост от бройката и размерите на подпроблемите се използва \nameref{sec:master-theorem}.
\end{itemize}

\subsubsection{Паметна сложност}
Паметната сложност описва колко памет е необходима на алгоритъма да се изпълни в зависимост от размера на входните данни. Измерва се с броя на променливите, които алгоритъмът използва.

Означения:
\begin{itemize}
    \item[] $O(1)$: Константна сложност - алгоритъмът използва фиксирано количество памет.
    \item[] $O(n)$: Линейна сложност - алгоритъмът използва пропорционално на размера на входните данни количество памет.
    \item[] $O(n^2)$: Квадратна сложност - алгоритъмът използва пропорционално на квадрата на размера на входните данни количество памет.
\end{itemize}

Пример:
\begin{itemize}
    \item[] Сортиране с мехурчета: Алгоритъмът за сортиране с мехурчета има паметна сложност $O(1)$, тъй като използва само фиксирано количество памет за променливи.
    \item[] Сортиране със сливане: Алгоритъмът за сортиране с сливане има паметна сложност $O(n)$, тъй като използва допълнителен масив с размер n за съхранение на междинните резултати.
\end{itemize}

\subsubsection{Мастър теорема}\label{sec:master-theorem}
Мастър теоремата е важен инструмент в анализа на алгоритмите, особено за алгоритми от тип "разделяй и владей". Тя ни позволява да намерим асимптотичната сложност на рекурсивни алгоритми, които разделят проблема на $k$ по-малки подпроблеми, решават ги рекурсивно и след това комбинират решенията.

Мастър теоремата се прилага за рекурентни уравнения от вида:
\begin{align*}
    T(n)&= aT\left(\frac{n}{b}\right) + f(n) =\\
        &= aT\left(\frac{n}{b}\right) + \Theta(n^c \log^k(n)) =
    \begin{cases}        
        \Theta(1)                   &, n=1\\
        \Theta(n^c)                 &, a<b^c,\ k=0\\
        \Theta(n^c \log^{k+1}(n))   &, a=b^c,\ k>-1\\
        \Theta(n^c \log\log(n))     &, a=b^c,\ k=-1\\
        \Theta(n^c)                 &, a=b^c,\ k<-1\\
        \Theta(n^{\log_b(a)})       &, a>b^c\\
    \end{cases}
\end{align*}
където:\vspace{8pt}

$T(n)$ е времевата сложност на алгоритъма за вход с размер n.

$a$ е броят на подпроблемите.

$b$ е размерът на всеки подпроблем.

$f(n)$ е времевата сложност на комбинирането на решенията на подпроблемите.

\subsubsection{Значение на анализа на сложността}
\begin{itemize}
    \item Сравняване на алгоритми: Анализът на сложността ни позволява да сравним различни алгоритми за решаване на един и същ проблем и да изберем най-ефективния.
    \item Оптимизиране на алгоритми: Анализът на сложността ни помага да оптимизираме алгоритмите, като намалим времевата и паметната им сложност.
    \item Разбиране на ограниченията: Анализът на сложността ни показва ограниченията на алгоритмите, например, кога алгоритъмът става непрактичен за големи размери на входните данни.
\end{itemize}

\pagebreak
\section{Търсене}
Търсенето на елементи е често срещана задача в програмирането, при която се цели да се намери конкретен елемент в множество от данни. Различните алгоритми за търсене се различават по ефективност, сложност и приложимост за различни видове данни.

\subsubsection{Линейно търсене}
Линейното търсене е най-простият алгоритъм за търсене на елемент в множество от данни. Този алгоритъм преглежда последователно всеки елемент в множеството, докато не намери търсения елемент или не стигне до края на множеството.

\begin{enumerate}\item[Как работи:]\end{enumerate}
\begin{enumerate}
    \item Започва от първия елемент в множеството.
    \item Сравнява текущия елемент с търсения елемент.
    \item Ако елементите са равни, алгоритъмът е успешен и връща индекса на елемента.
    \item Ако елементите не са равни, алгоритъмът преминава към следващия елемент в множеството.
    \item Процесът се повтаря, докато не се намери търсения елемент или не се стигне до края на множеството.
\end{enumerate}

\begin{itemize}\item[Предимства:]\end{itemize}
\begin{itemize}
    \item Прост за имплементиране: Лесен за разбиране и кодиране.
    \item Работи с всякакви данни: Не се изисква сортиране на множеството от данни.
\end{itemize}

\begin{itemize}\item[Недостатъци:]\end{itemize}
\begin{itemize}
    \item Бавен за големи множества от данни: Трябва да се прегледат всички елементи, което може да е бавно за големи множества.
    \item Времева сложност: $O(n)$: В най-лошия случай, алгоритъмът ще трябва да прегледа всички n елемента.
\end{itemize}

\pagebreak
\begin{itemize}\item[Реализация] в \cpp:\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Функция за линейно търсене
int linearSearch(int array[], int length, int target) {
    for (int i = 0; i < length; i++) {
        // Върни индекса на елемента, ако е равен на target
        if (array[i] == target) return i;
    }
    
    return -1; // Върни -1, ако не е намерен елемент
}
\end{lstlisting}\end{mdframed}

\subsubsection{Двоично търсене}
Двоичното търсене е много по-ефективен алгоритъм за търсене в сравнение с линейното търсене, но работи само със \textbf{сортирани} множества от данни. Този алгоритъм разделя множеството от данни на половина при всяка стъпка, като отхвърля половината, която не съдържа търсения елемент.

\begin{enumerate}\item[Как работи:]\end{enumerate}
\begin{enumerate}
    \item Започва от средата на множеството.
    \item Сравнява елемента в средата с търсения елемент.
    \item Ако елементите са равни, алгоритъмът е успешен и връща индекса на елемента.
    \item Ако елементите не са равни, алгоритъмът отхвърля половината от множеството, която не съдържа търсения елемент.
    \item Процесът се повтаря, като се разделя останалата част от множеството на половина, докато не се намери търсения елемент или не останат елементи за проверка.
\end{enumerate}

\begin{itemize}\item[Предимства:]\end{itemize}
\begin{itemize}
    \item Бърз за големи множества от данни: Времевата сложност е $O(log n)$, което е много по-бързо от $O(n)$ за линейното търсене.
    \item Ефективен за големи множества: Позволява бързо намиране на елементи в големи множества от данни.
\end{itemize}

\begin{itemize}\item[Недостатъци:]\end{itemize}
\begin{itemize}
    \item Работи само със сортирани данни: Не може да се използва за несортирани множества от данни.
    \item По-сложен за имплементиране: Изисква повече код и логика за имплементиране.
\end{itemize}

\begin{itemize}\item[Реализация] в \cpp:\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Функция за двоично търсене
int binarySearch(int array[], int length, int target) {
    int left = 0; // Лявата граница
    int right = length - 1; // Дясната граница

    while (left <= right) {
        int mid = left + (right - left) / 2; // Средата

        if (array[mid] == target) {
            return mid; // Върни индекса
        } else if (array[mid] < target) {
            left = mid + 1; // Отхвърли дясната
        } else {
            right = mid - 1; // Отхвърли дясната
        }
    }

    return -1; // Върни -1, ако не е намерен
}
\end{lstlisting}\end{mdframed}

\subsection{Обхождане на графика}
Графите са математически структури, които представляват взаимоотношения между обекти. Те се състоят от върхове (или нодове) и ръбове, които свързват върховете.

Видове графи:
\begin{itemize}
    \item[] Ненасочени графи: Ръбовете не са ориентирани, т.е. връзката между два върха е двупосочна.
    \item[] Насочени графи: Ръбовете са ориентирани, т.е. връзката между два върха е еднопосочна.
    \item[] Тегловни графи: Ръбовете имат тегла, които представляват разстояние, цена или друга величина.
\end{itemize}

С цел нагледност, ще дефинираме графите по следният начин:
\begin{mdframed}\begin{lstlisting}
// Използваме множество за да избегнем повторни връзки между ръбовете
#include <set>
#include <queue>

// Структура за връх
struct Vertex {
    int value = -1; // Стойност на върха
    bool visited = false; // Обходен ли е върхът
    // Множество от съседните върхове
    std::set<Vertex*> neighborhood; 
};

// Клас за граф
class Graph {
private:
    int vNum; // Брой върхове
    Vertex* vertexList; // Списък от върховете

public:
    // Създава граф с n върха
    Graph(int n) : vNum(n) {
        vertexList = new Vertex[n];

        for (int i = 0; i < n; i++) {
            vertexList[i].value = i;
        }
    }

    // Добавя (двупосочна) връзка между върховете a и b
    void addEdge(int a, int b) {
        vertexList[a].neighborhood.insert(&vertexList[b]);
        vertexList[b].neighborhood.insert(&vertexList[a]);
    }

    // DFS и BFS
    ...
\end{lstlisting}\begin{lstlisting}[firstnumber=92]
}
\end{lstlisting}\end{mdframed}

За обхождането на графи и търсенето на елементи във върховете се използват алгоритми като:

\subsubsection{Depth-First Search (DFS)}
DFS, или Обхождане в дълбочина, е алгоритъм за обхождане на структури от данни, като дървета и графи.
Той започва от даден връх, който се обозначава като корен, и обхожда структурата, като се движи по-дълбоко в нея, преди да се върне назад.
DFS е рекурсивен алгоритъм, който се реализира чрез рекурсивна функция.
Протича в $\Theta(\# \text{върхове}) + \Theta(\# \text{ръбове}) = \Theta(n)$ време.

В реални приложения, DFS се използва за:
\begin{itemize}
    \item[--] Намиране на всички върхове в граф.
    \item[--] Проверка за цикли в граф.
    \item[--] Намиране на най-краткия път в граф.
    \item[--] Търсене на топологично сортиране на граф.
\end{itemize}

\begin{itemize}\item[Реализация] в \cpp:\end{itemize}
\begin{mdframed}\begin{lstlisting}[firstnumber=35]
// Функция за DFS
Vertex* dfs(int start, int target) {
    Vertex* s = &vertexList[start];

    // Целта е намерена
    if (target == start) return s;

    // Отбелязваме текущия връх като посетен
    s->visited = true;

    for (Vertex *v : s->neighborhood) {
        // Пропуска вече посетени върхове
        if (v->visited) continue;

        // Продължава да търси в следващия връх рекурсивно
        return dfs(v->value, target);
    }

    // Не сочи към нищо когато целта не е намерена
    return nullptr;
}
\end{lstlisting}\end{mdframed}

След търсенето е удачно да се върнат \code{visited} стойностите на върховете на \code{false}, за да се избегнат нежелани грешки при повторни търсения.

\subsubsection{Breadth-First Search (BFS)}
BFS, или Обхождане в ширина, е алгоритъм за обхождане на структури от данни, като дървета и графи.
Той започва от даден връх, който се обозначава като корен, и обхожда структурата, като се движи по-широко в нея, преди да се движи по-дълбоко.
BFS е нерекурсивен алгоритъм, който се реализира чрез опашка. Протича в $\Theta(\# \text{върхове}) + \Theta(\# \text{ръбове}) = \Theta(n)$ време.

В реални приложения, BFS се използва за:
\begin{itemize}
    \item[--] Намиране на всички върхове в граф.
    \item[--] Проверка за цикли в граф.
    \item[--] Намиране на най-краткия път в граф.
\end{itemize}

\begin{itemize}\item[Реализация] в \cpp:\end{itemize}\vspace{-6pt}
\begin{mdframed}\begin{lstlisting}[firstnumber=57]
// Функция за BFS
Vertex* bfs(int start, int target) {
    std::queue<Vertex*> q; // Празна опашка за върхове
    Vertex *s = &vertexList[start];

    // Целта е намерена
    if (target == start) return s;

    // Отбелязваме текущия връх като посетен
    s->visited = true;
    q.push(s);

    while (!q.empty()) {
        // Вземаме следващия елемент в опашката
        Vertex *u = q.front();
        q.pop(); // Махаме го от опашката

        // Вкарваме всеки съседен връх в опашката
        for (Vertex *v : u->neighborhood) {
            // Пропуска вече посетени върхове
            if (v->visited) continue;

            // Целта е намерена
            if (target == v->value) return v;

            v->visited = true;
            q.push(v);
        }
    }
\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[firstnumber=last]
    // Отбелязва обратно всички върхове като непосетени
    flushVisited();

    // Не сочи към нищо когато целта не е намерена
    return nullptr;
}
\end{lstlisting}\end{mdframed}

\section{Сортиране}
Сортирането в \cpp е процесът на подреждане на елементите на масив по определен признак. Обикновено се подреждат (сортират) числа по възходящ или низходящ ред.

В \cpp има различни алгоритми за сортиране, като Bubble Sort, Insertion Sort, Quick Sort, Merge Sort, и др.

Може да се използва вградената функция \code{std::sort()}, която е много ефективна и лесна за използване.
За да използвате \code{std::sort()}, трябва да включите заглавния файл \code<algorithm>.
Функцията \code{std::sort()} приема два итератора, които определят началото и края на масива, който искате да сортирате.

\begin{itemize}\item[Пример:]\end{itemize}\
\begin{mdframed}\begin{lstlisting}
#include <algorithm>

int main() {
    int a[] = {5, 2, 8, 1, 9};
    int n = sizeof(a) / sizeof(a[0]);

    std::sort(a, a + n);
}
\end{lstlisting}\end{mdframed}

Въпреки лесното използване, не е най-бързият алгоритъм за сортиране. Поради тази причина ще разгледаме някои други алгоритми за сортиране. В алгоритмите, които ще разглеждаме, ще имаме предвид естественото сортиране по големина (от най-малко към най-голямо).
\pagebreak
\subsubsection{Swap}
Размяната на две променливи лежи в основата на повечето алгоритми за сортиране. Стандартно се използва временна променлива, която да съхранява едната от променливите, докато ги разменя.

\begin{itemize}\item[Реализация] в \cpp:\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Стандартна функция за размяна на две променливи
void swap(<type> &a, <type> &b) {
    <type> temp = a;
    a = b;
    b = temp;
}
\end{lstlisting}\end{mdframed}

\textbf{За напреднали:} Работейки с битовете на променливите, могат да се разменят две променливи, без да се създава временна променлива, чрез битовия оператор XOR (\code{\^}) по следния начин:
\begin{mdframed}\begin{lstlisting}
// Функция за размяна на две променливи чрез XOR
void swap(<type> &a, <type> &b) {
    a ^= b;
    b ^= a;
    a ^= b;
}
\end{lstlisting}\end{mdframed}

По този начин могат да се разменят променливи от примитивен тип, или променливи с примитивен характер (напр. \code{std::string} могат да се разменят по този начин, като се използват \code{char} адреси в параметрите на функцията).
\pagebreak
\subsubsection{Bubble sort}
Bubble Sort е алгоритъм за сортиране, който е сравнително прост за разбиране и реализиране.
Той работи, като сравнява съседни елементи в масив и ги разменя, ако са в неправилен ред.
Процесът се повтаря, докато масивът не е сортиран.
Bubble Sort е "in-place"\ алгоритъм, което означава, че не е нужно да се създава нов масив за сортиране.
Той е нестабилен алгоритъм, което означава, че елементите с еднаква стойност не запазват относителното си положение в масива след сортиране.
Bubble Sort е сравнително бавен алгоритъм, особено за големи масиви.

\begin{itemize}\item[Реализация] в \cpp:\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Функция за Bubble Sort
void bubbleSort(int arr[], int size) {
    // Първоначално се предполага, че масивът е сортиран
    bool sorted = true;

    for (int i = 0; i < size - 1; i++) {
        // Разменя съседни елементи, ако са в неправилен ред
        if (arr[i] > arr[i + 1]) {
            // Отбелязва масива за повторна проверка
            sorted = false;
            swap(arr[i], arr[i + 1]);
        }
    }

    // Повтаря сортирането, докато масивът не е сортиран
    if (!sorted) bubbleSort(arr, size);
}
\end{lstlisting}\end{mdframed}

Времева сложност: $O(n^2)$
\pagebreak
\subsubsection{Insertion sort}
Insertion Sort е друг алгоритъм за сортиране, който е лесен за разбиране и реализиране.
Той работи, като изгражда сортиран подмасив от масива, елемент по елемент.
Insertion Sort е "in-place"\ алгоритъм, което означава, че не е нужно да се създава нов масив за сортиране.
Той е стабилен алгоритъм, което означава, че елементите с еднаква стойност запазват относителното си положение в масива след сортиране.
Insertion Sort е ефективен за малки масиви, но е бавен за големи масиви.

\begin{itemize}\item[Реализация] в \cpp:\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Функция за Insertion Sort
void insertionSort(int arr[], int size) {
    // Изследваме всяка стойност от масива
    for (int i = 1; i < size; i++) {
        int key = arr[i];

        int j = i - 1;
        // Докато изследвания елемент е по-малък от предходните,
        while (j >= 0 && arr[j] > key) {
            // разменяме надолу (Bubble-down)
            swap(arr[j + 1], arr[j]);
            j--;
        }
    }
}
\end{lstlisting}\end{mdframed}

Времева сложност: $\Theta(n\log n), O(n^2)$

\subsubsection{Quick Sort}
Quick Sort е един от най-ефективните алгоритми за сортиране, който използва стратегия "разделяй и владей".
Работи, като избира "пивот"\ (pivot) елемент и разделя масива на две подмасиви - елементи по-малки от пивота и елементи по-големи от него.
Алгоритъмът рекурсивно прилага същата логика на подмасивите, докато не се получи сортиран масив.
Не изисква допълнителна памет за нови масиви, тъй като сортира на място.
Не запазва относителното положение на елементите с еднаква стойност.
За практическо приложение, той е предпочитан за сортиране на големи набори от данни.
\pagebreak
\begin{itemize}\item[Реализация] в \cpp:\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Функция за разделение на подмасиви
int partition(int arr[], int low, int high) {
    int pivot = arr[high]; // Избиране на пивот

    int i = low - 1; // Индекс на по-малкия елемент
    for (int j = low; j < high; j++) {
        // Ако текущият елемент е по-малък или равен на пивота
        if (arr[j] < pivot) {
            i++; // Увеличава индекса на по-малкия елемент
            swap(arr[i], arr[j]);
        }
    }

    // Поставяне на пивота на мястото му
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

// Функция за Quick Sort
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // Индекс, на който пивотът е поставен
        int pivot = partition(arr, low, high);

        // Рекурсивно сортиране на елементите преди и след пивота
        quickSort(arr, low, pivot - 1);
        quickSort(arr, pivot + 1, high);
    }
}
\end{lstlisting}\end{mdframed}

Времева сложност: $\Theta(n\log n), O(n^2)$

\subsubsection{Merge Sort}
Merge Sort е друг ефективен алгоритъм за сортиране, който използва стратегия "разделяй и владей".
Работи, като разделя масива на две равни подмасиви, рекурсивно сортира подмасивите и след това слива (merge) сортираните подмасиви в един сортиран масив.
Алгоритъмът рекурсивно прилага същата логика на подмасивите, докато не се получи сортиран масив.
Използва допълнителна памет за сливане на сортираните подмасиви.
Merge sort е стабилен, тъй като запазва относителното положение на елементите с еднаква стойност.
Той е един от най-ефективните алгоритми за сортиране, който е стабилен и ефективен за големи масиви, бърз и предсказуем по отношение на своята сложност.

\begin{itemize}\item[Реализация] в \cpp:\end{itemize}
\begin{mdframed}\begin{lstlisting}
// Функция за сливане на два сортирани масива
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1; // Брой елементи вляво
    int n2 = right - mid; // Брой елементи вдясно

    int *lArr = new int[n1]; // Временен ляв масив
    int *rArr = new int[n2]; // Временен ляв масив

    // Копиране на елементите от ляво и дясно в заделените масиви
    for (int i = 0; i < n1; i++) lArr[i] = arr[left + i];
    for (int j = 0; j < n2; j++) rArr[j] = arr[mid + 1 + j];

    // Сливане на сортираните подмасиви
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (lArr[i] <= rArr[j]) {
            arr[k] = lArr[i++];
        } else {
            arr[k] = rArr[j++];
        }
        k++;
    }

    // Копиране на останалите елементи
    while (i < n1) arr[k++] = lArr[i++];
    while (j < n2) arr[k++] = rArr[j++];

    // Освобождаване на временната памет
    delete[] lArr;
    delete[] rArr;
}

//  Функция за Merge sort
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid); // Сортира лявата част
        mergeSort(arr, mid + 1, right); // Сортира дясната част
        merge(arr, left, mid, right); // Слива сортираните части
    }
}                      
\end{lstlisting}\end{mdframed}

Времева сложност: $O(n\log n)$

\chapter*{Реализация на софтуерно приложение "Калкулатор за матрици"}
\addcontentsline{toc}{chapter}{Реализация на софтуерно приложение}
Софтуерното приложение, което реших да програмирам, се казва "Калкулатор за матрици" и е точно това което предполагате.

Работи на основата на система от въведени именувани матрици, с които можем да правим изчисления.
За да не става твърде обемен кода, основните функционалности над които ще се фокусирам са следните:
\begin{itemize}
    \item Ограничаване на позволения вход (чрез regex)
    \item Обработка на грешки
    \item Извеждане на информативни съобщения
    \item Извежане на помощно меню за интерактивни команди
    \item Въвеждане на матрици
    \item Извеждане на матрици
    \item Изчисляване и извеждане на сума на две матрици
    \item Изчисляване и извеждане на произведение на две матрици
\end{itemize}
\pagebreak
\begin{itemize}\item[Реализация] в \cpp:\end{itemize}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}
#include <iostream>	// За работа с входа и изхода
#include <string>	// За работа с низове
#include <regex>	// За работа с регулярни изрази
#include <vector>	// За работа с масиви

using namespace std;

#define PRINT(x) cout << x	// Макрос за извеждане на текст
#define PRINT_L(x) PRINT(x) << endl	// Макрос за извеждане на ред
#define ERR(x) cerr << x << endl	// Макрос за извеждане на грешки
#define INSERT(x) getline(cin, x)	// Макрос за въвеждане на текст
#define STR(x) to_string(x)			// Макрос за число в текст
#define D_STR(x) x.resize(x.length() - 4)	// Форматира double променливи
#define WELCOME PRINT_L("Welcome to the matrix calculator!")

namespace Input {
	// Регулярни изрази за входова сигурност
	const regex EXIT("[eE][xX][iI][tT]");
	const regex HELP("[hH][eE][lL][pP]");
	const string NAME("[a-zA-Z]*");
	const regex MATRIX(NAME);
	const regex INSERT_MATRIX("[iI][nN][sS][eE][rR][tT] [mM][aA][tT][rR][iI][xX] " + NAME);
	const regex SUM("[sS][uU][mM] " + NAME + " " + NAME);
	const regex MULT("[mM][uU][lL][tT][iI][pP][lL][yY] " + NAME + " " + NAME);
}

// Област на имената за изходни съобщения
namespace Output {
	// Изходни съобщения
	const string H0 = "Help menu:\n";
	const string H1 = "exit - Exits the system.\n";
	const string H2 = "help - Prints out this menu.\n";
	const string H3 = "[matrix name] - Prints out the selected matrix, if it exists.\n";
	const string H4 = "insert matrix [matrix name] - Creates a new matrix in the system. ";
	const string H5 = "Names must be unique. Keywords aren't allowed as names.\n";
	const string H6 = "sum [matrix name] [matrix name] - Sums the selected matrices";
	const string H7 = ", if they exist and are compatible.\n";
	const string H8 = "multiply [matrix name] [matrix name] - Multiplies the selected matrices";

\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[firstnumber=last]
	const string HELP = H0 + H1 + H2 + H3 + H4 + H5 + H6 + H7 + H8 + H7;
	const string ROWS = "Number of rows: ";
	const string COLS = "Number of columns: ";
	static string createdMatrix(string name, int rows, int cols) {
		return "Matrix " + name + " (" + STR(rows) + "x" + STR(cols) + ") created successfully!";
	}
	static string row(int i) { return "Row " + STR(i) + ": "; }
	static string initializedMatrix(string name) {
		return "Matrix " + name + " initialized successfully: ";
	}
	static string sum(string a, string b) {
        return "Sum (" + a + " + " + b + "):";
    }
	static string product(string a, string b) {
        return "Product (" + a + " * " + b + "):";
    }

	// Съобщения при грешки
	const string KEYWORD = "Keywords cannot be used for matrix names!";
	const string RETRY_MATRIX = "Please, try reinserting your matrix correctly!";
	const string INVALID_ROWS_COLS = "The inserted row number or column number is invalid!";
	const string INVALID_ELEMENT = "Invalid element detected!";
	const string INVALID_ROW_LENGTH = "The inserted row is too long or too short!";
    static string matrixNotFound(string name) {
		return "Matrix " + name + " not found!";
	}
	const string INCOMPATIBLE = "The matrices are with incompatible sizes!";
	static string matrixExists(string name) {
		return "Matrix " + name + " already exists! Try a different name!";
	}
}

// Класа за матрицата
class Matrix {
private:
	const string name;	// Име на матрицата
	const int rows;	// Редове
	const int cols;	// Колони
	vector<vector<double>> matrix; // Двумерен масив от double-и
\end{lstlisting}\end{mdframed}\vspace{-12pt}
\begin{mdframed}\begin{lstlisting}[firstnumber=last]

	// Връща конкретен елемент от двумерния масив
	double get(int y, int x) const { return matrix.at(y).at(x); }

public:
	// Конструктор за обекта матрица
	Matrix(string n, int r, int c) :
        name(n), rows(r), cols(c), matrix(r, vector<double>(c)) {}

	// Getter функции
	string getName() const { return name; }
	int getRows() const { return rows; }
	int getCols() const { return cols; }

	// Setter функция за редовете на матрицата
	void setRow(int i, vector<double> row) { matrix[i] = row; }

	// Функция за събиране на текущата матрица с матрица b
	Matrix add(Matrix *b) {
		// Локално създадена резултатна матрица
		Matrix sum = Matrix(this->name + " + " + b->name, rows, cols);
    
		for (int i = 0; i < sum.getRows(); i++) {
			vector<double> row; // Във всеки ред
			for (int j = 0; j < sum.getCols(); j++) {
				// Вкарваме всеки сумиран елемент съответно
				row.push_back(this->get(i, j) + b->get(i, j));
			}
			sum.setRow(i, row); // Записваме реда в резултатната матрица
		}

		return sum;
	}
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{mdframed}\begin{lstlisting}[firstnumber=last]

	// Функция за умножение на текущата матрица с матрица b
	Matrix times(Matrix *b) {
		// Локално създадена резултатна матрица
		Matrix prod = Matrix(this->name + " + " + b->name, this->rows, b->cols);

		for (int i = 0; i < this->rows; i++) {
			vector<double> row; // Във всеки ред на резултатната матрица
			for (int j = 0; j < b->cols; j++) {
				// Изчисляваме скаларния продукт на
				// ред от текущата матрица с колона от b
				double scalarProd = 0.0;
				for (int k = 0; k < b->rows; k++) {
					scalarProd += this->get(i, k) * b->get(k, j);
				}
				// Вкарваме всеки скаларен продукт съответно
				row.push_back(scalarProd);
			}
			prod.setRow(i, row); // Записваме реда в резултатната матрица
		}

		return prod;
	}

	// Стандартна функция за извеждане визуално на класа
	string toString() const {
		string mStr;
		for (int i = 0; i < rows; i++) {
			mStr += "\t";
			for (int j = 0; j < cols; j++) {
				string num(STR(get(i, j)));
				D_STR(num);
				mStr += num + "\t";
			}
			mStr += "\n";
		}
		return mStr;
	}
};

// Помощна структура при търсенето на матрици в системата
struct Matrices { Matrix *a, *b; };

// Глобален списък от създадените матрици
vector<Matrix*> matrixList;
\end{lstlisting}\end{mdframed}\vspace{-12pt}
\pagebreak
\begin{mdframed}\begin{lstlisting}[firstnumber=last]

// Област на имената за обработка на информация от низове
namespace Parser {
	// Функция за разделяне на низ на части спрямо разделителен символ
	static vector<string> splitStr(const string &str, char delimiter) {
		vector<string> tokens;
		size_t start = 0;
		size_t end = str.find(delimiter);

		while (end != string::npos) {
			tokens.push_back(str.substr(start, end - start));
			start = end + 1; // Move past the delimiter
			end = str.find(delimiter, start);
		}

		// Add the last token
		tokens.push_back(str.substr(start));

		return tokens;
	}

	// Обръща низ, с информация за ред на матрица, в ред на матрица
	static vector<double> rowStrToValues(const string &str, char delimiter) {
		vector<string> strValues = splitStr(str, delimiter);
		vector<double> values;

		values = vector<double>(strValues.size());
		for (int i = 0; i < strValues.size(); i++) {
			try {
				values[i] = stod(strValues[i]);
			}
			catch (invalid_argument e) {
				// При невалиден елемент връща грешка
				ERR(Output::INVALID_ELEMENT);
				return (vector<double>) NULL;
			}
		}

		return values;
	}

	static Matrix *findMatrix(string name);
	static struct Matrices fetchMatrices(string line);
	static void interpret(string &line);
}
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{mdframed}\begin{lstlisting}[firstnumber=last]

// Област на имената за конструирането на матриците
namespace Build {
	// Функция за инициализиране на елементите на матрица
	static void matrixInit(Matrix *m) {
		int rowsNum = m->getRows();
		string rowStr;
		vector<double> rowValues;

		for (int i = 0; i < rowsNum; i++) {
		retry_row:
			PRINT(Output::row(i + 1)); // Ред n-ти:
			INSERT(rowStr);

			rowValues = Parser::rowStrToValues(rowStr, ' ');

			// При грешки преповтаря въвеждането на същия ред
			if (rowValues == (vector<double>) NULL) goto retry_row;
			if (rowValues.size() != m->getCols()) {
				ERR(Output::INVALID_ROW_LENGTH);
				goto retry_row;
			}

			m->setRow(i, rowValues); // Записва реда в матрицата
		}

		// Съобщава успешната инициализация на матрицата
		PRINT_L(Output::initializedMatrix(m->getName()));
		PRINT_L(m->toString()); // Доказва успешната инициализация
	}

	// Функция за създаване на матрица
	static int matrix(string name) {
		string rows_s, cols_s;
		int rows, cols;

		PRINT(Output::ROWS);
		INSERT(rows_s);
		PRINT(Output::COLS);
		INSERT(cols_s);

		// Ако искаме да излезем по време на създаването, прекъсва процеса
		if (regex_match(rows_s, Input::EXIT) 
            || regex_match(cols_s, Input::EXIT)) return 0;
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{mdframed}\begin{lstlisting}[firstnumber=last]
		
		try {
			rows = stoi(rows_s);
			cols = stoi(cols_s);
		} catch (invalid_argument e) {
			// При неправилен вход връща грешка
			ERR(Output::INVALID_ROWS_COLS);
			return 0;
		}

		if (rows < 1 || cols < 1) {
			// При нелогични размери връща грешка
			ERR(Output::INVALID_ROWS_COLS);
			return 0;
		}

		// Въвежда новата празна матрица в системата
		matrixList.push_back(new Matrix(name, rows, cols));
		// Потвърждава създаването на матрицата
		PRINT_L(Output::createdMatrix(name, rows, cols));

		matrixInit(matrixList.back()); // Инициализатор на матрицата

		return 1;
	}
}

// Функция за търсене на конкретна матрица по име
static Matrix *Parser::findMatrix(string name) {
	if (matrixList.empty()) return nullptr;

	for (Matrix *m : matrixList) if (name == m->getName()) return m;

	// Ако не я намери, връща празен указател
	return nullptr;
}

// Функция за намиране на 2 матрици според информацията от line
static struct Matrices Parser::fetchMatrices(string line) {
	vector<string> names = splitStr(line, ' ');

	Matrix *a = Parser::findMatrix(names[1]);
	if (nullptr == a) {
		// При липсваща матрица търсенето връща грешка
		ERR(Output::matrixNotFound(names[1]));
		return {nullptr, nullptr};
	}
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{mdframed}\begin{lstlisting}[firstnumber=last]

	Matrix *b = Parser::findMatrix(names[2]);
	if (nullptr == b) {
		ERR(Output::matrixNotFound(names[2]));
		return { nullptr, nullptr };
	}

	// Връща структура с указатели към намерените матрици
	return { a, b };
}

// Функция за интерпретиране на командите
static void Parser::interpret(string &line) {
	if (regex_match(line, Input::HELP)) {
		// Извежда помощното меню
		PRINT_L(Output::HELP);
	} else if (regex_match(line, Input::INSERT_MATRIX)) {
		string name = line.substr(14, line.length());
		if (regex_match(name, Input::EXIT)) {
			ERR(Output::KEYWORD);
		} else if (nullptr == Parser::findMatrix(name)) {
			// Ако матрица с указаното име не съществува
			// опитва да създаде матрицата, ако
			// създаването е неуспешно връща грешка
			if (!Build::matrix(name)) ERR(Output::RETRY_MATRIX);
		} else ERR(Output::matrixExists(name)); // Ако матрцата съществува
	} else if (regex_match(line, Input::SUM)) {
		struct Matrices m = fetchMatrices(line);

		if (nullptr == m.a || nullptr == m.b) return;

		// Ако редовете и колоните не са съответно
		// равни по големина, събирането е невъзможно
		if ((m.a->getRows() != m.b->getRows()) 
			|| (m.a->getCols() != m.b->getCols())
		) {
			ERR(Output::INCOMPATIBLE);
			return;
		}

		PRINT_L(Output::sum(m.a->getName(), m.b->getName()));
		PRINT_L(((m.a)->add(m.b)).toString()); // Извежда резултатната матрица
\end{lstlisting}\end{mdframed}
\pagebreak
\begin{mdframed}\begin{lstlisting}[firstnumber=last]

	} else if (regex_match(line, Input::MULT)) {
		struct Matrices m = fetchMatrices(line);

		if (nullptr == m.a || nullptr == m.b) return;

		// Ако ред с колона и колона с ред не са съответно
		// равни по големина, събирането е невъзможно
		if ((m.a->getRows() != m.b->getCols())
			|| (m.a->getCols() != m.b->getRows())
		) {
			ERR(Output::INCOMPATIBLE);
			return;
		}

		PRINT_L(Output::product(m.a->getName(), m.b->getName()));
		PRINT_L(((m.a)->times(m.b)).toString()); // Извежда резултатната матрица
	} else if (regex_match(line, Input::MATRIX)) {
		// Търси матрица и ако я намери я извежда
		Matrix *a = Parser::findMatrix(line);
		if (nullptr != a) PRINT_L(a->toString());
	}

	// При произволно въведени входни данни не прави нищо
}

// Вход на програмата
int main() {
	WELCOME; // Приветстващо съобщение

	register string entry;
	INSERT(entry);

	// Докато не се въведе "exit" програмата ще очаква още команди
	while (!regex_match(entry, Input::EXIT)) {
		Parser::interpret(entry);

		INSERT(entry);
	}

	// След приключване на програмата е важно
	// да се освободи заделената за матриците памет
	if (!matrixList.empty()) for (Matrix *m : matrixList) delete m;

	return 0;
}
\end{lstlisting}\end{mdframed}

\begin{itemize}\item[Примерно] взаимодействие с потребителския интерфейс:\end{itemize}

\code{\"\ |\"} - Системно съобщение

\code{\"}\code{>|\"} - Въведената команда

\code{\"\ !\"} - Съобщение за грешка
\begin{mdframed}\begin{lstlisting}[language={}]
 |Welcome to the matrix calculator!
 |
>|tralala
 |
>|help
 |Help menu:
 |exit - Exits the system.
 |help - Prints out this menu.
 |[matrix name] - Prints out the selected matrix, if it exists.
 |insert matrix [matrix name] - Creates a new matrix in the system. Names must be unique. Keywords aren't allowed as names.
 |sum [matrix name] [matrix name] - Sums the selected matrices, if they exist and are compatible.
 |multiply [matrix name] [matrix name] - Multiplies the selected matrices, if they exist and are compatible.
 |
>|sum a b
 !Matrix a not found!
 |
>|insert matrix a
>|Number of rows: nope
>|Number of columns: 2
 !The inserted row number or column number is invalid!
 !Please, try reinserting your matrix correctly!
 |
>|insert matrix a
>|Number of rows: 3
>|Number of columns: nope
 !The inserted row number or column number is invalid!
 !Please, try reinserting your matrix correctly!
 |
>|insert matrix a
>|Number of rows: 3
>|Number of columns: 2
 |Matrix a (3x2) created successfully!
>|Row 1: nope 2
 !Invalid element detected!
>|Row 1: 1
 !The inserted row is too long or too short!
>|Row 1: 1 2 3
 !The inserted row is too long or too short!
\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[language={}]
>|Row 1: 1 2
>|Row 2: 3 4
>|Row 3: 5 6
 |Matrix a initialized successfully:
 |        1.00    2.00
 |        3.00    4.00
 |        5.00    6.00
 |
>|sum a b
 !Matrix b not found!
 |
>|insert matrix b
>|Number of rows: 2
>|Number of columns: 3
 |Matrix b (2x3) created successfully!
>|Row 1: 1 2 3
>|Row 2: 4 5 6
 |Matrix b initialized successfully:
 |        1.00    2.00    3.00
 |        4.00    5.00    6.00
 |
>|sum a b
 !The matrices are with incompatible sizes!
 |
>|a
 |        1.00    2.00
 |        3.00    4.00
 |        5.00    6.00
 |
>|b
 |        1.00    2.00    3.00
 |        4.00    5.00    6.00
 |
>|insert matrix c
>|Number of rows: 3
>|Number of columns: 2
 |Matrix c (3x2) created successfully!
>|Row 1: 4 6
>|Row 2: 12 3
>|Row 3: 1 1
 |Matrix c initialized successfully:
 |        4.00    6.00
 |        12.00   3.00
 |        1.00    1.00
 |
\end{lstlisting}\end{mdframed}
\begin{mdframed}\begin{lstlisting}[language={}]
>|sum a c
 |Sum (a + c):
 |        5.00    8.00
 |        15.00   7.00
 |        6.00    7.00
 |
>|sum c a
 |Sum (c + a):
 |        5.00    8.00
 |        15.00   7.00
 |        6.00    7.00
 |
>|multiply a c
 !The matrices are with incompatible sizes!
 |
>|multiply a b
 |Product (a * b):
 |        9.00    12.00   15.00
 |        19.00   26.00   33.00
 |        29.00   40.00   51.00
 |
>|multiply b a
 |Product (b * a):
 |        22.00   28.00
 |        49.00   64.00
 |
>|exit

MatrixCalc.exe exited with code 0 (0x0)
\end{lstlisting}\end{mdframed}

\end{document}