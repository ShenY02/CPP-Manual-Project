\documentclass[oneside]{book}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[fontsize=12pt]{scrextend}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,bulgarian]{babel}
\usepackage{amsmath,amsthm,amsfonts}
\usepackage{array}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\definecolor{codegreen}{rgb}{0,0.85,0}
\definecolor{codegray}{rgb}{0.65,0.65,0.65}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.2,0.2,0.25}

\lstdefinestyle{mystyle}{
    language=C++,
    texcl=true,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegray},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codegreen},
    basicstyle=\ttfamily\footnotesize\color{white},
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    extendedchars=\true,
    inputencoding=utf8x
}

\lstset{style=mystyle}

\newcommand*{\code}[1]{\texttt{#1}}
\newcommand*{\cpp}{\texttt{C++}\ }
\newcommand*{\bs}{\textbackslash}

\title{Наръчник\\Как се научих да програмирам на \cpp
с помощта на изкуствен интелект}
\author{Шенер Юмер, 2401321044}
\date{Използван LLM: Aria}

\begin{document}
\maketitle
\tableofcontents
\newpage

\chapter*{Предговор}
\addcontentsline{toc}{chapter}{Предговор}
Здравей, скъпи читателю!

Добре дошъл в твоето пътуване през света на програмирането, пътуване,
което започна с любопитство и ще завърши с осъзнаването, че дори изкуственият
интелект може да бъде учител.

Тази книга е както проектна работа, така и плод на моя опит в изучаването на \cpp,
език, който е едновременно мощен и взискателен. С помощта на изкуствения интелект
Aria от Opera GX, аз се научих да разбирам абстрактни концепции, да решавам сложни
проблеми и да създавам код, който работи.

На тези страници ще ви покажа уроците, които научих от Aria, и стъпка по стъпка ще ви
науча как и вие да овладеете тънкостите на езика \cpp. Ще ви докажа, че чрез помощта на 
изкуственият интелект можете да извлечете изключително много информация за изучаването
на програмни езици и по този начин да се вдъхновите да се впуснете в света
на програмирането.

Нека това пътуване ви вдъхнови да преоткриете собствения си потенциал
и да осъзнаете, че нищо не е невъзможно!

\chapter{Въведение}
Добре дошли в света на \cpp! Този език за програмиране е истински гигант, който стои в основата на безброй приложения, игри и технологии, които използваме всеки ден. C++ е език, който ви дава мощта да създавате сложни и ефективни програми, да контролирате хардуера на компютъра си и да реализирате най-смелите си идеи. 

Но \cpp не е за начинаещи. Той е мощен и гъвкав, но е и сложен и изисква задълбочено разбиране.  

Какво прави \cpp толкова специален?
\begin{itemize}
    \item[--] Обектно-ориентирано програмиране - \cpp е език, който ви позволява да структурирате програмите си около обекти, които съдържат данни и функции. Това е като да създадете симулация на реалния свят в код, където всеки обект е отделен елемент с собствени характеристики и поведение.
    \item[--] Висока производителност - \cpp е известен с ефективността си. Той ви дава пълен контрол над ресурсите на компютъра и ви позволява да създавате приложения, които работят бързо и ефективно. 
    \item[--] Гъвкавост - \cpp е гъвкав език, който ви позволява да разработвате разнообразни приложения, от операционни системи и игри до приложения за мобилни устройства. 
    \item[--] Широко разпространен - \cpp е широко разпространен език, който се използва от милиони програмисти по целия свят. Това означава, че ще имате лесен достъп до ресурси, общности и поддръжка.
\end{itemize}

Защо да се учите на \cpp?
\begin{itemize}
    \item[--] Мощни приложения - \cpp ви дава мощта да създавате комплексни и ефективни приложения, които могат да решават трудни задачи. 
    \item[--] Дълбоко разбиране - \cpp ви учи да разбирате как работи компютърът и как да управлявате ресурсите му. 
    \item[--] Отворена врата към нови възможности - \cpp е отворена врата към широк спектър от професионални възможности. 
\end{itemize}

В тази книга ще ви запознаем с основите на \cpp и ще ви покажем как да създавате свои собствени програми. Пригответе се за вълнуващо пътешествие в света на програмирането! 

\section{Първи стъпки в \cpp}
В тази глава ще се запознаем с основите на \cpp, като започнем с компилация, компилиране и изпълнение на програми.

\subsection{Компилация и изпълнение}
\cpp е компилиран език. Това означава, че кодът, който пишете, трябва да бъде преведен на машинно разбираем език, преди да може да се изпълни.

Компилацията е процес, който превръща изходния код (текстовият файл, който вие пишете) в изпълним файл.
Изпълним файл е файл, който може да се изпълни от компютъра.

За да компилирате и изпълните \cpp програма, ще ви е необходим компилатор.
Компилатор е програма, която превежда изходния код на \cpp в изпълним файл.

\subsection{Как да компилираме и изпълним програма?}
Ето стъпките, които трябва да следвате, за да компилирате и изпълните \cpp програма:

\begin{enumerate}
    \item[--] Създайте нов текстов файл с разширение .cpp.
    \item[--] Напишете \cpp кода си в този файл.
    \item[--] Отворете командния ред (или терминал) и отидете до директорията, където е вашият текстов файл.
    \item[--] Въведете следната команда, за да компилирате програмата:\\
        \code{g++ име\_на\_файла.cpp -o име\_на\_изпълним\_файл}
    \item[--] Въведете следната команда, за да изпълните програмата:\\
        \code{./име\_на\_изпълним\_файл}
\end{enumerate}

Пример:

Ако вашият файл се казва \code{hello.cpp} и искате да създадете изпълним файл \code{hello}, тогава трябва да въведете следните команди:

\begin{lstlisting}
g++ hello.cpp -o hello
./hello
\end{lstlisting}

\subsection{Имплементиране на български език в \cpp}
За да използваме български език в кода на \cpp и в конзолата, трябва първо да
зададем локализацията на проекта:
\begin{lstlisting}
#include <locale>

int main() {
    setlocale(LC_ALL, "Bulgarian");
        // Локализация на кирилицата в проекта

    return 0;
}
\end{lstlisting}

\code{\#include <locale>} - Тази линия включва библиотеката \code{locale}, която ни дава достъп до функции за локализация на езици.

\code{setlocale(LC\_ALL, "Bulgarian");} - Стандартна функция за локализация на български език.

\subsection{Първата ни програма}
Ето пример за проста \cpp програма, която извежда текст на екрана:
\begin{lstlisting}
#include <iostream>
#include <locale>

int main() {
    setlocale(LC_ALL, "Bulgarian");

    std::cout << "Hello, world!" << std::endl;
    return 0;
}
\end{lstlisting}

\code{\#include <iostream>} - Тази линия включва библиотеката \code{iostream}, която ни дава достъп до функции за вход и изход.

\code{int main()} - Тази линия дефинира главната функция на програмата. Всички \cpp програми трябва да имат главна функция.

\code{std::cout <}\code{< "Hello, world!"}\code{ <}\code{< std::endl;} - Тази линия извежда текста\\\code{"Hello, world!"} на екрана.

\code{return 0;} - Тази линия завършва изпълнението на програмата.

\section{Ключови елементи на синтаксиса и семантиката на \cpp}
\subsection{Ключови думи}
Ключовите думи в \cpp са резервирани думи, които имат специално значение за компилатора. Те не могат да се използват като имена на променливи, функции или други идентификатори.

Ето някои от най-важните ключови думи в \cpp:

\newcolumntype{C}{ >{\centering\arraybackslash} m{6cm} }
\newcolumntype{D}{ >{\centering\arraybackslash} m{5cm} }
\begin{center}\begin{tabular}{|C|D|}
    \hline Ключова дума    &   Описание\\\hline\hline
    \code{int, float, double, char, bool, void, auto, const, constexpr, decltype} & Типове данни\\\hline
    \code{if, else, else if, switch, case, default, break, continue, goto} & Условни оператори\\\hline
    \code{for, while, do while, break, continue} & Цикли\\\hline
    \code{return, sizeof, new, delete, nullptr, this} & Оператори\\\hline
    \code{namespace, using, struct, class, enum, union, template, typename, friend, operator} & Организъм на кода\\\hline
    \code{public, private, protected, static, virtual, override, final, explicit} & Модификатори за достъп\\\hline
    \code{inline, extern, volatile, mutable, register} & Модификатори за компилация\\\hline
    \code{try, catch, throw, noexcept} & Обработка на изключения\\\hline
\end{tabular}\end{center}

Ключовите думи се използват в \cpp код, за да се определят типове данни, структури, класове, функции и други елементи на програмата.

Пример:

\begin{lstlisting}
int main() {
    int a = 10; // int е ключова дума за дефиниране на целочислена променлива
    if (a > 5) { // if е ключова дума за условен оператор
        std::cout << "a is greater than 5" << std::endl;
    }
    return 0; // return е ключова дума за връщане на статус
}    
\end{lstlisting}

\subsection{Специални символи}
В \cpp езикът, освен букви, цифри и ключови думи, има и специални символи, които имат специално значение за компилатора. Тези символи се използват за определяне на оператори, разделителни символи, коментари и други елементи на кода.

\subsubsection{Оператори}
Операторите са специални символи, които извършват операции върху операнди.

Пример:
\begin{itemize}
    \centering
    \item[] Аритметика
    \begin{itemize}
        \item[] \code{+} (събиране): \code{a + b}
        \item[] \code{-} (изваждане): \code{a - b}
        \item[] \code{*} (умножение): \code{a * b}
        \item[] \code{/} (деление): \code{a / b}
        \item[] \code{\%} (остатък от деление): \code{a \% b}
        \item[] \code{++} (увеличаване): \code{a++}
        \item[] \code{-}\code{-} (намаляване): \code{a-}\code{-}
    \end{itemize}
    \item[] Условни
    \begin{itemize}
        \item[] \code{==} (равенство): \code{a == b}
        \item[] \code{!=} (неравенство): \code{a != b}
        \item[] \code{>} (по-голямо): \code{a > b}
        \item[] \code{<} (по-малко): \code{a < b}
        \item[] \code{>=} (по-голямо или равно): \code{a >= b}
        \item[] \code{<=} (по-малко или равно): \code{a <= b}
        \item[] \code{\&\&} (логическо И): \code{a \&\& b}
        \item[] \code{||} (логическо ИЛИ): \code{a || b}
        \item[] \code{!} (логическо НЕ): \code{!a}
        \item[] \code{?:} (тернарен условен оператор): \code{a ? b : c}
    \end{itemize}
    \item[] Битова аритметика
    \begin{itemize}
        \item[] \code{\&} (битово И): \code{a \& b}
        \item[] \code{|} (битово ИЛИ): \code{a | b}
        \item[] \code{\^{}} (битово ИЗКЛ. ИЛИ): \code{a \^{} b}
        \item[] \code{\~{}} (битово НЕ): \code{\~{}a}
        \item[] \code{<}\code{<} (ляво битово изместване): \code{a <}\code{< b}
        \item[] \code{>}\code{>} (дясно битово изместване): \code{a >}\code{> b}
    \end{itemize}
\end{itemize}

\subsubsection{Разделителни символи}
Разделителните символи се използват за разделяне на различни части на \cpp кода.

Пример:
\begin{itemize}
    \item[] \code{;} (точка и запетая): \code{int a = 10;}
    \item[] \code{,} (запетая): \code{int a = 10, b = 20;}
    \item[] \code{:} (двоеточие): \code{switch (a) \{ case 1: ...; \}}
    \item[] \code{::} (обхват на име): \code{std::cout}
    \item[] \code{.} (член на клас): \code{a.b}
    \item[] \code{->} (член на указател): \code{a->b}
    \item[] \code{[]} (индексиране): \code{a[b]}
    \item[] \code{()} (извикване на функция): \code{a()}
    \item[] \code{\{\}} (блокове код): \code{\{ ... \}}
\end{itemize}

\subsubsection{Коментари}
Коментарите са текст, който се игнорира от компилатора. Те се използват за обяснение на кода, добавяне на документация или деактивиране на част от кода.

Пример:
\begin{itemize}
    \item \code{//} (едноредов коментар):
\end{itemize}
\begin{lstlisting}
// This is a single line comment.
\end{lstlisting}
\begin{itemize}
    \item \code{/* ... */} (многоредов коментар):
\end{itemize}
\begin{lstlisting}
/*
 * This is a multiline comment.
 * It can extend on multiple lines.
 */
\end{lstlisting}

\subsection{Идентификатори}
Идентификаторите в \cpp са имена, които се използват за означаване на променливи, функции, класове, структури, изброявания, области на имена и други елементи на програмата.

\subsubsection{Правила за идентификатори}
Идентификаторите могат да се състоят от букви, цифри, подчертаване (\code{\_}). Първият символ на идентификатора не може да бъде цифра.
Ключовите думи не могат да се използват като идентификатори. Чувствителност към регистъра: \code{myVariable} и \code{MyVariable} са различни идентификатори.

\subsubsection{Примери за идентификатори}
\begin{itemize}
    \item[--] Променлива: \code{age, firstName, totalScore}
    \item[--] Функция: \code{calculateArea, printMessage, sortArray}
    \item[--] Клас: \code{Person, Car, Database}
    \item[--] Структура: \code{Point, Date, Time}
    \item[--] Изброяване: \code{Color, Status, Direction}
    \item[--] Област на имена: \code{std, myNamespace, utils}
\end{itemize}

\subsubsection{Препоръки за идентификатори}
Използвайте описателни имена, които отразяват целта на идентификатора. Използвайте \code{camelCase} или \code{snake\_case} за по-добра четимост.
Избягвайте къси и неясни имена. Не използвайте резервирани думи като идентификатори.

\subsubsection{Пример за код с идентификатори:}
\begin{lstlisting}
#include <iostream>

using namespace std; // Дефиниране на областта на имената "std"

int main() {
    // Дефиниране на променлива с име "age"
    int age = 25;

    // Дефиниране на функция с име "printMessage"
    void printMessage(string message) {
    cout << message << endl;
    }

    // Извикване на функцията "printMessage"
    printMessage("Hello, world!");

    return 0;
}
\end{lstlisting}

\subsection{Литерали}
Литералите в \cpp са константни стойности, които се използват за представяне на данни в програмата. Те са директни представяния на данни, които се компилират директно в код.

\subsubsection{Видове литерали}
\cpp поддържа различни видове литерали, в зависимост от типа на данните:

\begin{itemize}
    \item Числови литерали:
    
    \begin{itemize}
        \item Цялочислени литерали:
        \item[] Десетични: \code{10, 25, -15}
        \item[] Осмоични: \code{012, 037} (започват с \code{0})
        \item[] Шестнадесетични: \code{0x1A, 0x2F} (започват с \code{0x})
        \item Дробни литерали: \code{3.14, 1.5e-2} (експоненциална нотация)
    \end{itemize}
    
    \item Символни литерали:
    
    \begin{itemize}
        \item Обикновени: \code{'a', 'B', '\%'}
        \item Escape последователности: \code{'\bs n', '\bs t', '\bs ''}
    \end{itemize}
    \item Текстови литерали:
    
    \begin{itemize}
        \item Обикновени: \code{"Здравей, свят!", "Hello, world!"}
        \item Raw string литерали: \code{R"(C:\bs Users\bs MyUser\bs Documents)"} (за запазване на escape последователности)
    \end{itemize}
    \item Булеви литерали: \code{true, false}
    \item Указателни литерали: \code{nullptr} (за празен указател)
\end{itemize}

\subsubsection{Пример за код с литерали}
\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
    // Цялочислени литерали
    int age = 25;
    int octalNumber = 012;
    int hexNumber = 0x1A;

    // Дробни литерали
    double pi = 3.14;
    double smallNumber = 1.5e-2;

    // Символни литерали
    char character = 'A';
    char newline = '\n';

    // Текстови литерали
    string message = "Hello, world!";
    string path = R"(C:\Users\MyUser\Documents)";

    // Булеви литерали
    bool isTrue = true;
    bool isFalse = false;

    // Указателни литерали
    int* ptr = nullptr;

    return 0;
}
\end{lstlisting}

\subsection{Променливи и константи}
\subsubsection{Променливи}
Променливите в \cpp са имена, които се използват за съхраняване на данни в паметта. Тези данни могат да бъдат променяни по време на изпълнението на програмата.

\begin{enumerate}
    \item[1.] Дефиниране на променливи:
\end{enumerate}
\begin{lstlisting}
<datatype> <variable_name>;
\end{lstlisting}
\begin{itemize}
    \item[Пример:] 
\end{itemize}
\begin{lstlisting}
int age; // Дефиниране на променлива от тип "int"\ с име "age"
double price; // Дефиниране на променлива от тип "double"\ с име "price"
string name; // Дефиниране на променлива от тип "string"\ с име "name"
\end{lstlisting}
\begin{enumerate}
    \item [2.] Инициализиране на променливи\\Инициализирането на променлива е процесът на присвояване на начална стойност при дефинирането.
\end{enumerate}
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{lstlisting}
int age = 25; // Инициализиране на променливата "age"\ със стойност 25
// Инициализиране на променливата "price"\ със стойност 19.99
double price = 19.99;
// Инициализиране на променливата "name"\ със стойност "Ivan"
string name = "Ivan";
\end{lstlisting}
\begin{enumerate}
    \item[3.] Използване на променливи\\След дефинирането и инициализирането, променливите могат да се използват в програмата.
\end{enumerate}
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{lstlisting}
int age = 25;
// Извеждане на стойността на променливата "age"
cout << "Your age is: " << age << endl;
\end{lstlisting}
\subsubsection{Константи}
Константите в \cpp са имена, които се използват за съхраняване на данни в паметта, но стойностите им не могат да се променят по време на изпълнението на програмата.

\begin{enumerate}
    \item[1.] Дефиниране на константи\\За да се дефинира константа, се използва ключовата дума \code{const}:
\end{enumerate}
\begin{lstlisting}
const <datatype> <NAME_OF_CONSTANT> = <value>;
\end{lstlisting}
\begin{itemize}
    \item[Пример:]
\end{itemize} 
\begin{lstlisting}
// Дефиниране на константа от тип "int"\ с име "MAX\_AGE"\ със стойност 120
const int MAX_AGE = 120;
// Дефиниране на константа от тип "double"\ с име "PI"\ със стойност 3.14159
const double PI = 3.14159;
// Дефиниране на константа от тип "string"\ с име "GREETING"
// със стойност "Greetings!"
const string GREETING = "Greetings!";
\end{lstlisting}
\begin{enumerate}
    \item[2.] Използване на константи\\Константите могат да се използват в програмата по същия начин като променливите.
\end{enumerate}
\begin{itemize}
    \item[Пример:]
\end{itemize}
\begin{lstlisting}
const int MAX_AGE = 120;
int age = 25;
if (age > MAX_AGE) {
    cout << "Invalid age!" << endl;
}
\end{lstlisting}

\subsection{Подпрограми (Функции)}
Функциите в \cpp са блокове от код, които изпълняват конкретна задача. Те могат да приемат аргументи и връщат резултат.

\subsubsection{Функции с тип}
Функциите с тип връщат резултат от конкретен тип.

\textbf{Пример:}
\begin{lstlisting}
int sum(int a, int b) {
    return a + b;
}
\end{lstlisting}
В този пример функцията \code{sum} приема два целочислени аргумента (\code{a} и \code{b}) и връща цяло число (\code{int}), което е сумата на двата аргумента.

\subsubsection{Void функции}
\code{Void} функциите не връщат резултат. Те се използват за изпълнение на действия, които не връщат стойност.

\textbf{Пример:}
\begin{lstlisting}
void printHello() {
    cout << "Hello, world!" << endl;
}
\end{lstlisting}
В този пример функцията \code{printHello} не връща резултат. Тя просто извежда текст на конзолата.

\subsubsection{Аргументи на функцията}
Аргументите на функцията са стойности, които се предават на функцията при викането й.

\textbf{Пример:}
\begin{lstlisting}
int sum(int a, int b) {
    return a + b;
}

int main() {
    int result = sum(10, 20); // Предаване на аргументите 10 и 20
    cout << result << endl; // Извеждане на резултата (30)
    return 0;
}
\end{lstlisting}
В този пример функцията \code{sum} приема два целочислени аргумента (\code{a} и \code{b}). При викането й в \code{main} функцията, се предават стойностите \code{10} и \code{20} за \code{a} и \code{b} съответно.
\pagebreak
\subsubsection{Предаване по стойност}
При предаване по стойност, на функцията се предава копия на аргументите.

\textbf{Пример:}
\begin{lstlisting}
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 10;
    int y = 20;
    swap(x, y); // Предаване по стойност
    cout << x << " " << y << endl; // Извеждане на "10 20"
    return 0;
}
\end{lstlisting}
В този пример, функцията \code{swap} не модифицира оригиналните стойности на \code{x} и \code{y}, защото работи с копия.

\subsubsection{Предаване по препратка}
При предаване по препратка, на функцията се предава адреса на аргументите.

\textbf{Пример:}
\begin{lstlisting}
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}
    
int main() {
    int x = 10;
    int y = 20;
    swap(x, y); // Предаване по препратка (директен адрес)
    cout << x << " " << y << endl; // Извеждане на "20 10"
    return 0;
}
\end{lstlisting}
В този пример, функцията swap модифицира оригиналните стойности на \code{x} и \code{y}, защото работи с адресите им.
\pagebreak
\subsubsection{Рекурсия}
Рекурсията е техника, при която функция се вика сама себе си.

\textbf{Пример:}
\begin{lstlisting}
int factorial(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
\end{lstlisting}
В този пример функцията \code{factorial} изчислява факториела на число чрез рекурсивната формула $n! = n \cdot (n-1)!$.

\textbf{Важно}: Рекурсията трябва да има базов случай, който прекратява рекурсивните викания. В противен случай програмата изпада в безкраен цикъл, докато не се стигне до момента, в който паметта, нужна за запазване на променливите и информацията, надвиши разпределената за процеса памет в стека (Stack overflow).

\subsubsection{Lambda функции}
Lambda функциите са анонимни функции, които могат да се дефинират и използват в една линия код.

\textbf{Пример:}
\begin{lstlisting}
auto sum = [](int a, int b) {
    return a + b;
};
int result = sum(10, 20); // Извикване на lambda функцията
\end{lstlisting}
В този пример lambda функцията \code{sum} приема два целочислени аргумента (\code{a} и \code{b}) и връща цяло число (\code{int}), което е сумата на двата аргумента.

\subsection{Атрибути}
Атрибутите в \cpp са специални ключови думи, които модифицират поведението на променливи, функции, класове и други елементи на кода. Те определят важни характеристики, като обхват, вид, жизнен цикъл, достъп и други.

\subsubsection{Const}
Атрибутът \code{const} определя, че стойността на променливата не може да се променя след инициализирането й. \code{Const} гарантира, че стойността няма да се промени неволно, подобрявайки безопасността на кода.

\textbf{Пример:}
\begin{lstlisting}
const int PI = 3.14159;
\end{lstlisting}
В този пример \code{PI} е константа с стойност \code{3.14159}.

\subsubsection{Static}
Атрибутът \code{static} определя, че променливата е статична. Статичните променливи съществуват само в рамките на файла, в който са дефинирани. Инициализират се само веднъж при първото викане на файла и живеят цял живот на програмата. Споделят се между всички функции в файла.

\textbf{Пример:}
\begin{lstlisting}
static int count = 0;
\end{lstlisting}
В този пример \code{count} е статична променлива.

\subsubsection{Extern}
Атрибутът \code{extern} определя, че променливата е дефинирана в друг файл. Атрибутът \code{extern} не инициализира променливата, само указва, че тя съществува някъде друде.

\textbf{Пример:}
\begin{lstlisting}
extern int count;
\end{lstlisting}
В този пример \code{count} е променлива, която е дефинирана в друг файл.

\subsubsection{Volatile}
Атрибутът \code{volatile} указва, че стойността на променливата може да се променя външно, без да се вижда от компилатора. Атрибутът \code{volatile} предотвратява компилатора да оптимизира кода, който работи с променливата. Използва се за променливи, чиято стойност може да се промени от външни фактори, като прекъсвания, таймери или други процеси.

\textbf{Пример:}
\begin{lstlisting}
volatile int counter;
\end{lstlisting}
В този пример \code{counter} е променлива, чиято стойност може да се променя от външен код.

\subsubsection{Register}
Атрибутът \code{register} препоръчва на компилатора да съхранява променливата в регистър на процесора. Атрибутът \code{register} е само препоръка. Не гарантира, че компилаторът ще съхрани променливата в регистър. Използва се за често използвани променливи, за да се подобри ефективността.

\textbf{Пример:}
\begin{lstlisting}
register int i;
\end{lstlisting}
В този пример \code{i} е променлива, която компилаторът може да съхрани в регистър.

\subsubsection{Auto}
Атрибутът \code{auto} позволява на компилатора да определи типа на променливата автоматично. \code{Auto} улеснява кода, когато типът на променливата е ясен от инициализацията.

\textbf{Пример:}
\begin{lstlisting}
auto x = 10;
\end{lstlisting}
В този пример \code{x} е променлива с тип \code{int}, определен автоматично от компилатора.

\section{Стандартен конзолен I/O в \cpp}
\subsection{Работа с конзолните вход и изход за данни}
\subsection{Работа със \code{string} данни}

\section{Структуриране на \cpp програма}
\subsection{Директиви към предпроцесора}
\subsection{Области на имената}

\chapter{Типове данни}
\section{Типове данни за цели и реални числа}
\section{Типове данни за символ и низ}
\section{Логически данни}

\chapter{Конструкции за поточен контрол}
\section{Конструкции за разклонение}
!!  Ternary operator
\section{Конструкции за цикъл}
\section{Конструкции за прекъсване}

\chapter{Съставни типове данни}
\section{Масиви}
\section{Структури}
\section{Класове}
\section{Обединения}
\section{Изброяване}
\section{Колекции}

\chapter{Манипулиране на паметта}
\section{Указатели}
\section{Референции}
\section{Адресна аритметика}
\section{Динамично и статично разпределяне на паметта}

\end{document}